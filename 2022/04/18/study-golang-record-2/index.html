<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="CrossTime的个人博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Golang学习记录之二 |  CrossTime的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-study-golang-record-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Golang学习记录之二
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/18/study-golang-record-2/" class="article-date">
  <time datetime="2022-04-18T06:38:41.000Z" itemprop="datePublished">2022-04-18</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">20 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>​    基于上一篇文章的补充，后续若遇到其他坑或者有新的小技巧会继续补充的哈(。・∀・)ノ</p>
<h2 id="1、函数的返回值可以是一个函数"><a href="#1、函数的返回值可以是一个函数" class="headerlink" title="1、函数的返回值可以是一个函数"></a>1、函数的返回值可以是一个函数</h2><p>在golang中，需要对每个函数定义好返回值的类型（如果有返回值的话），其中返回值的类型可以是一个函数类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SprintFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(a ...&#123;&#125;)</span></span> <span class="type">string</span> &#123;     <span class="comment">// 将func(a ...&#123;&#125;) string作为函数返回类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprint(a...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := SprintFunc()                       <span class="comment">// 这里变量b的类型为func(a ...&#123;&#125;) string，是一个函数类型</span></span><br><span class="line">	fmt.Println(b(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>))              <span class="comment">// 调用函数b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、windows文件锁"><a href="#2、windows文件锁" class="headerlink" title="2、windows文件锁"></a>2、windows文件锁</h2><p>在很多场景下，会遇到多个协程同时写文件的操作，需要用到文件锁以保证写入顺序</p>
<p>golang的syscall库内置了设置文件锁函数Flock，其函数原理是调用系统的flock这个api，但只能在linux平台内使用，windows上没有flock这个api</p>
<p>在github上搜索第三方库，发现1个库：github.com&#x2F;gofrs&#x2F;flock（其余还有很多其他的库，如github.com&#x2F;zbiljic&#x2F;go-filelock， github.com&#x2F;juju&#x2F;fslock ，都大同小异）</p>
<p>但使用方式与linux的略有不同，linux文件锁的参数是打开的文件句柄，代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">syscall.Flock(<span class="type">int</span>(f.Fd()), syscall.LOCK_EX)  <span class="comment">// 文件上锁</span></span><br><span class="line">_, _ = io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)            <span class="comment">// 文件写入</span></span><br><span class="line">syscall.Flock(<span class="type">int</span>(f.Fd()), syscall.LOCK_UN)  <span class="comment">// 文件解锁</span></span><br></pre></td></tr></table></figure>

<p>文件上锁之后，仍然可以对该文件句柄进行写入操作，只是其他协程再尝试上锁会被阻塞（句柄不同）</p>
<p>但上面那个github.com&#x2F;gofrs&#x2F;flock   在windows平台上的参数是文件路径</p>
<p>如果先上锁再进行文件写入操作，则会返回写入失败（写入文件前都会先给文件上锁的吧。。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(file <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	lock := fslock.New(file)</span><br><span class="line">	lockErr := lock.Lock()     <span class="comment">// 文件上锁</span></span><br><span class="line">	<span class="keyword">if</span> lockErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(lockErr)</span><br><span class="line">	&#125;</span><br><span class="line">	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	_, _ = io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)   <span class="comment">// 会返回写入失败</span></span><br><span class="line">	lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	write(<span class="string">&quot;123.txt&quot;</span>)</span><br><span class="line">	write(<span class="string">&quot;123.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">The process cannot access the file because it is being used by another process.</span><br></pre></td></tr></table></figure>

<p>windows上文件锁具体如何配合写文件，这些github上都没写（这一点好坑，害得我研究了几天）</p>
<p>某一天突然灵光一闪，想到了如何使用，那就是创建另外一个文件当作文件锁，在获取到文件锁之后再写到输出文件里，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gofrs/flock&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/remeh/sizedwaitgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(file <span class="type">string</span>, wgscan *sizedwaitgroup.SizedWaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wgscan.Done()</span><br><span class="line">	fmt.Println(file)</span><br><span class="line">	f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open err: &quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;try to write 123&quot;</span>)</span><br><span class="line">	fileLock := flock.New(<span class="string">&quot;temp/outputFile.pid&quot;</span>)      <span class="comment">// 创建另一个文件outputFile.pid当做文件锁，</span></span><br><span class="line">                                                      <span class="comment">// 对该文件上锁，如果能够上锁，则认为当前没有协程对123.txt进行写操作，则可以放心写入</span></span><br><span class="line">	<span class="keyword">for</span> &#123;                                             <span class="comment">// TryLock会尝试获取文件锁，但获取失败时不会堵塞，所以这里需要使用循环来不断尝试获取</span></span><br><span class="line">		locked, err := fileLock.TryLock()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			util.Error(<span class="string">&quot;output file lock failed: &quot;</span>, err.Error(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> locked &#123;                                   <span class="comment">// 如果成功获取到文件锁，则退出循环</span></span><br><span class="line">			<span class="keyword">defer</span> fileLock.Unlock()                   <span class="comment">// 函数退出时会解锁</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;write 123&quot;</span>)</span><br><span class="line">	_, err2 := io.WriteString(f, <span class="string">&quot;123\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write:&quot;</span>, err2)</span><br><span class="line">	&#125;</span><br><span class="line">	f.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;write 123 done&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;quit write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wgscan := sizedwaitgroup.New(<span class="number">2</span>)                   <span class="comment">// 创建两个协程</span></span><br><span class="line">	pwd, _ := os.Getwd()</span><br><span class="line">	wgscan.Add()</span><br><span class="line">	<span class="keyword">go</span> write(filepath.Join(pwd,<span class="string">&quot;123.txt&quot;</span>), &amp;wgscan)   <span class="comment">// 往123.txt里写文件</span></span><br><span class="line">	wgscan.Add()</span><br><span class="line">	<span class="keyword">go</span> write(filepath.Join(pwd,<span class="string">&quot;123.txt&quot;</span>), &amp;wgscan)</span><br><span class="line">	wgscan.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、性能提升"><a href="#3、性能提升" class="headerlink" title="3、性能提升"></a>3、性能提升</h2><p>当开发一些比较大的程序时，性能提升就显得比较重要了（否则运行慢导致没人用&#x2F;(ㄒoㄒ)&#x2F;~~）</p>
<p>下面是一些提升的心得：</p>
<p><strong>1）用到比较大的结构体作为函数返回值&#x2F;参数时，使用指针形式（否则会拷贝一份到内存中，徒增消耗）</strong></p>
<p><strong>2）在构造字符串时，对于拼接比较多的情况，比如</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c,d,e,f,g <span class="type">string</span></span><br><span class="line">output := a+b+c+d+e+f+g   <span class="comment">// 字符串拼接操作</span></span><br><span class="line">fmt.Println(output)</span><br></pre></td></tr></table></figure>

<p>这种拼接构造字符串效率其实是比较低的，使用专门的构造字符串的结构<code>bytes.Buffer</code>，效率会更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b,c,d,e,f,g <span class="type">string</span></span><br><span class="line">output := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">buff.WriteString(a)</span><br><span class="line">buff.WriteString(b)</span><br><span class="line">buff.WriteString(c)</span><br><span class="line">buff.WriteString(d)</span><br><span class="line">buff.WriteString(e)</span><br><span class="line">buff.WriteString(f)</span><br><span class="line">buff.WriteString(g)</span><br><span class="line">fmt.Println(buff.String())</span><br></pre></td></tr></table></figure>

<p><strong>3）使用预分配</strong></p>
<p>因为golang中切片是不定长的，可以使用append函数将数据插入到切片中，但其实插入到切片之前，golang会先检查切片的长度是否达到了容量上限，如果达到了上限，是需要先申请内存，对切片进行扩容操作，再进行数据插入</p>
<p>如果已经知道切片长度，则使用make函数提前一次性申请内存空间，再进行赋值操作效率会更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br><span class="line">src := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无预分配: 162 ns/op</span></span><br><span class="line"><span class="keyword">var</span> dst []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">	dst = <span class="built_in">append</span>(dst, src[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预分配，32.3 ns/op，提升了5倍</span></span><br><span class="line">dst2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">	dst2 = <span class="built_in">append</span>(dst2, src[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://wudaijun.com/2019/09/go-performance-optimization/">https://wudaijun.com/2019/09/go-performance-optimization/</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1165922">https://cloud.tencent.com/developer/article/1165922</a></p>
<h2 id="4、context之WithCancel的使用"><a href="#4、context之WithCancel的使用" class="headerlink" title="4、context之WithCancel的使用"></a>4、context之WithCancel的使用</h2><p>在golang中会经常使用协程来进行并发处理，对于想控制协程退出的场景下，需要使用context来控制协程何时退出</p>
<p>context.WithCancel()函数接受一个 Context 并返回其子Context和取消函数cancel，当调用cancel取消函数时，所有位于context(函数参数)下面的子context(函数返回值)都会收到消息而退出，代码示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 父context(利用根context得到)</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 父context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch1(ctx)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 子context，注意：这里虽然也返回了cancel的函数对象，但是未使用</span></span><br><span class="line">	valueCtx, _ := context.WithCancel(ctx)</span><br><span class="line">	<span class="comment">// 子context的子协程</span></span><br><span class="line">	<span class="keyword">go</span> watch2(valueCtx)</span><br><span class="line"> </span><br><span class="line">	fmt.Println(<span class="string">&quot;现在开始等待3秒,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 调用cancel()</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;等待3秒结束,调用cancel()函数&quot;</span>)</span><br><span class="line">	cancel()</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 再等待5秒看输出，可以发现父context的子协程和子context的子协程都会被结束掉</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;最终结束,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，父context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;父context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;收到信号，子context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;子context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">现在开始等待<span class="number">3</span>秒,time= <span class="number">1649582546</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582546</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582546</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582547</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582547</span></span><br><span class="line">子context的协程监控中,time= <span class="number">1649582548</span></span><br><span class="line">父context的协程监控中,time= <span class="number">1649582548</span></span><br><span class="line">等待<span class="number">3</span>秒结束,调用cancel()函数</span><br><span class="line">收到信号，父context的协程退出,time= <span class="number">1649582549</span></span><br><span class="line">收到信号，子context的协程退出,time= <span class="number">1649582549</span></span><br><span class="line">最终结束,time= <span class="number">1649582554</span></span><br></pre></td></tr></table></figure>

<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yzf279533105/article/details/107290645">https://blog.csdn.net/yzf279533105/article/details/107290645</a></p>
<h2 id="5、range是值拷贝出来的副本"><a href="#5、range是值拷贝出来的副本" class="headerlink" title="5、range是值拷贝出来的副本"></a>5、range是值拷贝出来的副本</h2><p>在使用range遍历slice或者map的时候，要注意的是，循环的值都是被range值拷贝出来的副本值</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="type">int</span></span><br><span class="line">    Num   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t []Test</span><br><span class="line">    t = <span class="built_in">append</span>(t,Test&#123;Index:<span class="number">1</span>,Num:<span class="number">1</span>&#125;)</span><br><span class="line">    t = <span class="built_in">append</span>(t,Test&#123;Index:<span class="number">2</span>,Num:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        v.Num += <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v:= <span class="keyword">range</span> t&#123;</span><br><span class="line">        fmt.Println(v.Index,v.Num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>因为这里的v已经不是原来t中的了，而是值拷贝出来的副本值，副本值，副本值！</p>
<p>当然，map中的结果也是一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]Test)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    v.Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，可以使用指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t []*Test</span><br><span class="line">t = <span class="built_in">append</span>(t,&amp;Test&#123;Index:<span class="number">1</span>,Num:<span class="number">1</span>&#125;)</span><br><span class="line">t = <span class="built_in">append</span>(t,&amp;Test&#123;Index:<span class="number">2</span>,Num:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">    v.Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">2</span> <span class="number">102</span></span><br></pre></td></tr></table></figure>

<p>对于切片来说，可以使用下标来修改数组的值，在golang中通过下标访问（类似于基址寻址）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> t &#123;</span><br><span class="line">    t[i].Num += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span> <span class="number">101</span></span><br><span class="line"><span class="number">2</span> <span class="number">102</span></span><br></pre></td></tr></table></figure>



<h2 id="6、句柄"><a href="#6、句柄" class="headerlink" title="6、句柄"></a>6、句柄</h2><p>在linux中，打开文件的时候会产生一个句柄，但在进行socket连接时也会产生一个句柄，如果socket没有断开连接的话  会导致文件句柄过多而产生异常</p>
<p>在使用协程进行并发式的http请求时，建议创建一个全局的http.Client，使用默认的transport配置</p>
<p>如果忽略ssl证书问题的需求，可以复制一份默认配置，添加上自己的配置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transport默认配置：</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">   Proxy: ProxyFromEnvironment,</span><br><span class="line">   DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">      Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">      KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">      DualStack: <span class="literal">true</span>,</span><br><span class="line">   &#125;).DialContext,</span><br><span class="line">   ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">   MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">   IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">   TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">   ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7、静态资源打包进二进制"><a href="#7、静态资源打包进二进制" class="headerlink" title="7、静态资源打包进二进制"></a>7、静态资源打包进二进制</h2><p>有时候二进制需要结合前端页面来进行展示，网上大多使用embed来嵌入静态文件，但在迁移部署的时候需要将二进制程序和静态前端页面一起打包，不光麻烦，看着也不够优雅，若只有一个二进制程序多省事(～￣▽￣)～</p>
<p>这时候需要将前端的静态文件打包进二进制中，即以golang的代码形式写入源码中</p>
<p>网上搜了搜，这里我使用的是第三方库github.com&#x2F;libragen&#x2F;felix，这个库能将静态前端页面进行打包成http.fileServer（具体原理详见参考链接），供gin以中间件的形式使用（中间件用于对HTTP Request请求进行拦截处理，类型为gin.HandlerFunc，函数类型），前端我是用的vue进行生成，打包过程如下：</p>
<p><strong>1）vue打包生成前端静态页面</strong>（不知道如何使用vue生成静态页面的麻烦自行百度，这里不多介绍）</p>
<p><strong>2）felix ginbin -s ${前端编译好的dist目录路径}</strong>  </p>
<p>-s 前端编译好的代码目录,也可以适用于普通的前端项目 -d输出go代码的目录(包),默认当前工作目录</p>
<p>打包好的部分代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包完成后会生成felixbin目录，里面的gin_static.go即为生成的golang代码</span></span><br><span class="line"><span class="comment">// - felix</span></span><br><span class="line"><span class="comment">// - felixbin</span></span><br><span class="line"><span class="comment">//   -  gin_static.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gin中间件的处理函数，在配置gin的时候会用到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGinStaticBinMiddleware</span><span class="params">(urlPrefix <span class="type">string</span>)</span></span> (gin.HandlerFunc, <span class="type">error</span>) &#123;</span><br><span class="line">	fs, err := create(zipData)   <span class="comment">// 创建http.fileServer文件系统</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	fileserver := http.FileServer(fs)</span><br><span class="line">	<span class="keyword">if</span> urlPrefix != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		fileserver = http.StripPrefix(urlPrefix, fileserver)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		urlPath := strings.TrimSpace(c.Request.URL.Path)</span><br><span class="line">		<span class="keyword">if</span> urlPath == urlPrefix &#123;</span><br><span class="line">			urlPath = path.Join(urlPrefix, indexHtml)</span><br><span class="line">		&#125;</span><br><span class="line">		f, err := fs.Open(urlPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fi, err := f.Stat()</span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(urlPath,<span class="string">&quot;.html&quot;</span>)&#123;</span><br><span class="line">			c.Header(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || !fi.IsDir() &#123;</span><br><span class="line">			fileserver.ServeHTTP(c.Writer, c.Request)</span><br><span class="line">			c.Abort()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）项目中创建并配置gin</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">binStaticMiddleware, err := felixbin.NewGinStaticBinMiddleware(<span class="string">&quot;/&quot;</span>)  <span class="comment">// 创建中间件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r.Use(binStaticMiddleware)   <span class="comment">// 使用创建的中间件</span></span><br><span class="line">api := r.server.Group(<span class="string">&quot;/_/api&quot;</span>)      <span class="comment">//创建后端接口 /_/api/get_status</span></span><br><span class="line">api.GET(<span class="string">&quot;/get_status&quot;</span>, getStatus)   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStatus</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;reverse platform running ok.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://mojotv.cn/2019/07/27/how-to-serve-frontend-code-with-api-in-go">https://mojotv.cn/2019/07/27/how-to-serve-frontend-code-with-api-in-go</a></p>
<h2 id="8、结构体继承与组合"><a href="#8、结构体继承与组合" class="headerlink" title="8、结构体继承与组合"></a>8、结构体继承与组合</h2><p>如果一个struct嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的方法，从而实现继承</p>
<p>如果一个struct嵌套了另一个有名的结构体，那么这个模式叫做组合，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pluginBase <span class="keyword">struct</span> &#123;         </span><br><span class="line">	Enable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> enabled() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Enable</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> setEnabled(enable <span class="type">bool</span>) &#123;</span><br><span class="line">	p.Enable = enable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rule <span class="keyword">struct</span> &#123;</span><br><span class="line">	ruleName <span class="type">string</span></span><br><span class="line">	payload  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rule)</span></span> getRuleName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.ruleName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cmdInjection <span class="keyword">struct</span> &#123;</span><br><span class="line">	pluginBase                    <span class="comment">// 匿名继承pluginBase结构体，可以直接使用pluginBase的enabled和setEnabled方法</span></span><br><span class="line">	name       <span class="type">string</span></span><br><span class="line">	injectRule rule               <span class="comment">// 嵌套有名的结构体，需要通过injectRule.getRuleName来调用方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cmdInjection)</span></span> getName() <span class="type">string</span> &#123;   <span class="comment">// cmdInjection本身的方法</span></span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建结构体</span></span><br><span class="line">	injectRule := rule&#123;</span><br><span class="line">		ruleName: <span class="string">&quot;linux command inject&quot;</span>,</span><br><span class="line">		payload:  <span class="string">&quot;; cat /etc/passwd&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	cmdInjectPlugin := cmdInjection&#123;</span><br><span class="line">		name:       <span class="string">&quot;command injection&quot;</span>,</span><br><span class="line">		injectRule: injectRule,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(cmdInjectPlugin.getName())                   <span class="comment">// 调用cmdInjectPlugin本身的方法</span></span><br><span class="line">	fmt.Println(cmdInjectPlugin.injectRule.getRuleName())    <span class="comment">// 调用嵌套结构体injectRule的方法</span></span><br><span class="line">	fmt.Println(cmdInjectPlugin.enabled())                   <span class="comment">// 调用继承结构体pluginBase的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">command injection</span><br><span class="line">linux command inject</span><br><span class="line"><span class="literal">false</span>         <span class="comment">// 没有对enable赋值，默认为false</span></span><br></pre></td></tr></table></figure>



<h2 id="9、golang接口"><a href="#9、golang接口" class="headerlink" title="9、golang接口"></a>9、golang接口</h2><p>golang中的接口是一个或多个方法签名的集合，只有方法声明，没有实现，没有数据字段</p>
<p>接口可以匿名嵌入其它接口，或嵌入到结构中</p>
<p>将结构体赋值给接口时，会发生拷贝，而<strong>接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针</strong> </p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">int</span></span><br><span class="line">	c <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// 定义元素类型为接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := Test&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	i = b</span><br><span class="line">	fmt.Println(i, b)     <span class="comment">// 输出i和b的值</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;b), fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;i))   <span class="comment">// 打印地址</span></span><br><span class="line">	b.b = <span class="number">2</span>               <span class="comment">// 修改原结构体的元素，接口的值不变</span></span><br><span class="line">	fmt.Println(i, b)</span><br><span class="line">    i = &amp;b                <span class="comment">// 当赋值为结构体b的指针时，接口和结构体指向的是同一个</span></span><br><span class="line">	i.(*Test).a = <span class="number">2</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;b), fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125;</span><br><span class="line"><span class="number">0xc000024040</span> <span class="number">0xc0000100a0</span>    <span class="comment">// 打印接口i和结构体b的地址  接口内部存储的是指向这个复制品的指针</span></span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span> &lt;<span class="literal">nil</span>&gt;&#125; &#123;<span class="number">1</span> <span class="number">2</span> &lt;<span class="literal">nil</span>&gt;&#125;      <span class="comment">// 原结构体b的值变了，但接口i不变</span></span><br><span class="line"><span class="number">0xc000024040</span> <span class="number">0xc000024040</span>    <span class="comment">// 接口赋值为指针时，两者指向一致</span></span><br></pre></td></tr></table></figure>

<p>当尝试通过接口来修改结构体的值时，会报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">int</span></span><br><span class="line">	c <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	b := Test&#123;a: <span class="number">1</span>&#125;</span><br><span class="line">	i = b</span><br><span class="line">	i.(Test).a = <span class="number">1</span>                        <span class="comment">// 复制品不能通过接口赋值，接口赋值结构体指针的时候可以</span></span><br><span class="line">    fmt.Println(&amp;i.(Test).a)              <span class="comment">// 不能获取结构体内的元素的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">174</span>:<span class="number">13</span>: cannot assign to i.(Test).a  </span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">178</span>:<span class="number">14</span>: cannot take the address of i.(Test).a  </span><br></pre></td></tr></table></figure>



<p>只要某个类型a拥有该接口b的所有方法签名（通过自己定义或者匿名继承都可，不懂继承的可见上面的第8条结构体继承与组合），即算实现该接口，无需显示声明实现了哪个接口，类型a也会被认为接口b类型，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pluginBase <span class="keyword">struct</span> &#123;</span><br><span class="line">	Enable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> enabled() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Enable</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pluginBase)</span></span> setEnabled(enable <span class="type">bool</span>) &#123;</span><br><span class="line">	p.Enable = enable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> plugin <span class="keyword">interface</span> &#123;                  <span class="comment">// 定义接口，声明需要实现enabled和setEnabled方法</span></span><br><span class="line">	enabled() <span class="type">bool</span></span><br><span class="line">	setEnabled(enable <span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cmdInjection <span class="keyword">struct</span> &#123;               <span class="comment">// 定义结构体cmdInjection，因为匿名继承了pluginBase结构体，也就继承了其方法</span></span><br><span class="line">	pluginBase                           <span class="comment">// 当然也可以cmdInjection自己定义enabled和setEnabled方法</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cmdInjection)</span></span> getName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	plugins := []plugin&#123;&#125;                               <span class="comment">// 定义元素类型为plugin的切片</span></span><br><span class="line">	plugins = <span class="built_in">append</span>(plugins, &amp;cmdInjection&#123;           <span class="comment">// 因为cmdInjection实现了接口plugin声明的方法，所以cmdInjection被认为是plugin类型</span></span><br><span class="line">		name: <span class="string">&quot;command injection&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> _, plugin := <span class="keyword">range</span> plugins &#123;                  <span class="comment">// 通过循环遍历插件</span></span><br><span class="line">		plugin.run()                                  <span class="comment">// 运行插件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">command injection</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，比如我想定义很多插件，但每个插件都有自己定义的结构体，想使用统一的切片来储存初始化后的插件，但golang中需要对切片的元素类型进行声明，就可以使用上面的方法：统一定义一个plugin的接口（有点类似于基类），下面的各种不同的插件（例如cmdInjection插件，有点像子类）实现plugin接口声明的方法，使用统一的切片[]plugin来保存初始化后的插件，后续可以通过循环来调用插件的方法，这样代码看起来就很优雅O(∩_∩)O</p>
<h2 id="10、golang结构体的初始化"><a href="#10、golang结构体的初始化" class="headerlink" title="10、golang结构体的初始化"></a>10、golang结构体的初始化</h2><p>目前我见到的结构体初始化赋值的方法大概分为3类：</p>
<p><strong>1）创建结构体时进行赋值（若引用外部package的结构体，只能赋值首字母大写的成员变量）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    output <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := test&#123;</span><br><span class="line">    Name: <span class="string">&quot;test&quot;</span>,   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2） 通过构造函数（若外部package定义的结构体中有私有变量(首字母小写)，可以通过这个方法，但构造函数名首字母需大写）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录结构：</span></span><br><span class="line"><span class="comment">// - test1</span></span><br><span class="line"><span class="comment">//   - test1.go</span></span><br><span class="line"><span class="comment">// - test2</span></span><br><span class="line"><span class="comment">//   - test2.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.go</span></span><br><span class="line"><span class="keyword">package</span> test1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    private <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTest</span><span class="params">(name, private <span class="type">string</span>)</span></span> *test &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;test&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        private: private,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.go</span></span><br><span class="line"><span class="keyword">package</span> test2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test1 := test1.NewTest(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;private&quot;</span>)</span><br><span class="line">    fmt.Println(test1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3）通过另类的构造函数（这里仅记录方法，看着比较优雅）</strong></p>
<p>golang中可以给变量定义为函数类型，函数的返回值也可以是函数类型</p>
<p>可以定义赋值函数，再将赋值函数传入构造函数中，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PoCMon <span class="keyword">struct</span> &#123;</span><br><span class="line">    passwords []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PocMonOption <span class="function"><span class="keyword">func</span><span class="params">(p *PoCMon)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPasswords</span><span class="params">(passwords []<span class="type">string</span>)</span></span> PocMonOption &#123;          <span class="comment">// 定义并返回赋值函数，在赋值函数中设置结构体变量的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(p *PoCMon)</span></span> &#123;</span><br><span class="line">        p.passwords = passwords</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPoCMon 根据选项生成PoCMon实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPoCMon</span><span class="params">(options ...PocMonOption)</span></span> *PoCMon &#123;                <span class="comment">// 结构体构造函数，传参赋值函数</span></span><br><span class="line">    p := &amp;PoCMon&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">        option(p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">password := []<span class="type">string</span>&#123;<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;admin&quot;</span>&#125;</span><br><span class="line">p = NewPoCMon(                               <span class="comment">// 调用构造函数，参数为赋值函数</span></span><br><span class="line">        WithPasswords(password),              <span class="comment">// 传参赋值函数</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://p611148aadsl.github.io/2022/04/18/study-golang-record-2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2022/04/05/study-golang-record-1/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Golang学习记录之一</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> CrossTime
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/crosstime.png" alt="CrossTime的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>